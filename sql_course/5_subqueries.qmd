---
title: "Subqueries and views"
author: Danny Volkaerts
date: last-modified
date-format: "DD MMM, YYYY" 
format:
  revealjs: 
    theme: default
filters:
  - interactive-sql
databases:
  - name: hr
    path: "https://raw.githubusercontent.com/dannyvolkaerts/something/main/hr.sql"
  - name: hr-not-editable
    path: "https://raw.githubusercontent.com/dannyvolkaerts/something/main/hr.sql"
    editable: false
---

### Subquery

Per definitie is een subquery een query die in een andere query wordt genest.\

Stel dat je alle werknemers moet vinden die zich bevinden op de locatie met id 1700.

![](sql_course_images/subqueries_ex1.png){#fig-erd-hr}

---

### Subquery

Dan zoeken we eerst alle departementen op locatie 1700:

``` {.sql .interactive .hr}
SELECT *
FROM departments
WHERE location_id = 1700;
```

------------------------------------------------------------------------

### Subquery 

Dan gebruiken we deze lijst om de werknemers te vinden:

``` {.sql .interactive .hr}
SELECT employee_id, first_name, last_name
FROM employees
WHERE department_id IN (1 , 3, 9, 10, 11)
ORDER BY first_name , last_name;
```

------------------------------------------------------------------------

### Subquery 

* Probleem: lijst met department_id's kan heel lang zijn\
* Probleem 2: omslachtig wanneer we werknemers uit ander departement willen 

---

### Subquery

``` {.sql .interactive .hr}
SELECT employee_id, first_name, last_name
FROM employees
WHERE department_id IN (
        SELECT department_id
        FROM departments
        WHERE location_id = 1700)
ORDER BY first_name , last_name;
```

:::{.notes}
De query tussen haakjes wordt een subquery genoemd. Het wordt ook wel een inner query of inner select genoemd.\
De query die de subquery bevat, wordt een outer query of outer select genoemd.
:::

------------------------------------------------------------------------

### Subquery voorbeeld 1

Vind de werknemers met het hoogste salaris:

``` sql
SELECT employee_id, first_name, last_name, salary
FROM employees
WHERE salary = (SELECT MAX(salary) FROM employees)
ORDER BY first_name , last_name;
```

------------------------------------------------------------------------

### Subquery voorbeeld 2

Wat is de vraagstelling bij volgende query?

``` {.sql .interactive .hr}
SELECT employee_id, first_name, last_name, salary
FROM employees
WHERE salary >= ALL (SELECT MIN(salary) FROM employees GROUP BY department_id)
ORDER BY first_name , last_name;
```

::: notes

:::

------------------------------------------------------------------------

### VIEWs

Een view is als een virtuele tabel die geproduceerd wordt door het uitvoeren van een query. Het relationele databasebeheersysteem (RDBMS) slaat een view op als een SELECT met naam in de databasecatalogus.\
Telkens wanneer je een SELECT opdracht geeft die een view naam bevat, voert de RDBMS de view-definiërende query uit om de virtuele tabel te creëren. Die virtuele tabel wordt dan gebruikt als brontabel van de query.



------------------------------------------------------------------------

### VIEWs

** Gebruik: Views helpen je om de gegevens voor een specifieke groep gebruikers in te pakken. Je kunt bijvoorbeeld een overzicht maken van salarisgegevens voor de medewerkers van de afdeling Financiën.\
Views helpen databasebeveiliging te handhaven. In plaats van gebruikers toegang te geven tot databasetabellen, maak je een view om alleen noodzakelijke gegevens te onthullen en geef je gebruikers toegang tot de view.

```{.sql}
CREATE VIEW view_name 
AS
SELECT-statement
```

---

### VIEWs voorbeeld

``` {.sql .interactive .hr}
CREATE VIEW employee_contacts AS
    SELECT first_name, last_name, email, phone_number, department_name
    FROM employees e INNER JOIN
        departments d ON d.department_id = e.department_id
    ORDER BY first_name;
```

:::{.notes}
SELECT 
    *
FROM
    employee_contacts;
:::


------------------------------------------------------------------------

### VIEWs voorbeeld 2

``` {.sql .interactive .hr}
CREATE VIEW payroll (first_name , last_name , job, compensation) AS
    SELECT 
        first_name, last_name, job_title, salary
    FROM
        employees e
            INNER JOIN
        jobs j ON j.job_id= e.job_id
    ORDER BY first_name;
```

:::{.notes}
SELECT \
    job, \
    MIN(compensation), \
    MAX(compensation), \
    AVG(compensation)\
FROM\
    payroll\
WHERE\
    job LIKE 'A%'\
GROUP BY job;\
:::


--------

### drop VIEW

``` sql
DROP VIEW view_name;
```
