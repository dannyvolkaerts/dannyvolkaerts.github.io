[
  {
    "objectID": "SQL.html#hr-sample-data",
    "href": "SQL.html#hr-sample-data",
    "title": "Interactive-sql",
    "section": "HR sample data",
    "text": "HR sample data\nHere we will use a sample Database called HR that manages the HR data of the small businesses which is collected from www.sqltutorial.org. And to create the database, a SQLite script file was used when rendering the document. Read the extension docs for details."
  },
  {
    "objectID": "SQL.html#erd-of-hr-database",
    "href": "SQL.html#erd-of-hr-database",
    "title": "Interactive-sql",
    "section": "ERD of HR database",
    "text": "ERD of HR database\nThe following database diagram illustrates the HR sample database:\n\nFigure 1: ERD of HR database"
  },
  {
    "objectID": "SQL.html#editable-example",
    "href": "SQL.html#editable-example",
    "title": "Interactive-sql",
    "section": "Editable Example",
    "text": "Editable Example\nAnd now, you can run all sort of queries from the tables of the HR databases.\n\nselect * from regions;"
  },
  {
    "objectID": "SQL.html#not-editable-example",
    "href": "SQL.html#not-editable-example",
    "title": "Interactive-sql",
    "section": "Not editable example",
    "text": "Not editable example\nYou can also create “not-editable” code chunk (that is, you simply can run the query but won’t be able to edit/modify it) for HR database. And to do this, just use another instance of database under the database key in the yaml with a different name and use the option editable: false."
  },
  {
    "objectID": "SQL.html#not-editable-example-1",
    "href": "SQL.html#not-editable-example-1",
    "title": "Interactive-sql",
    "section": "Not editable example",
    "text": "Not editable example\n\nselect * from employees;"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Danny Volkaerts",
    "section": "",
    "text": "Hi! Welcome to my digital space! As a data enthousiast I’m fueled by curiosity and motivated by the goal of turning data into actionable insights. Whether it’s through Machine Learning, data analysis, or data visualizations, I explore data in all its forms to unlock opportunities and drive innovation.\nHere, as a work in progress, I share my experiences, discoveries, and the lessons learned along the way with companies and fellow data enthusiasts. Dive into my courses, read through case studies, or reach out directly if you have any data related question!\n\n\n\n\nCatholic University of Leuven, Leuven | Belgium Bio-engineering Sciences\n\n\n\n\n\nUC Leuven-Limburg Research & Expertise | Data Scientist | April 2018 - present\nIMEC | Process Engineer | Sept 2012 - April 2018\n\n\n \n  \n   \n  \n    \n     LinkedIn"
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "Danny Volkaerts",
    "section": "",
    "text": "Catholic University of Leuven, Leuven | Belgium Bio-engineering Sciences"
  },
  {
    "objectID": "index.html#experience",
    "href": "index.html#experience",
    "title": "Danny Volkaerts",
    "section": "",
    "text": "UC Leuven-Limburg Research & Expertise | Data Scientist | April 2018 - present\nIMEC | Process Engineer | Sept 2012 - April 2018"
  },
  {
    "objectID": "sql_course/index_sql.html",
    "href": "sql_course/index_sql.html",
    "title": "SQL Cursus",
    "section": "",
    "text": "SQL - Structured Query Language - is een fundamenteel hulpmiddel voor iedereen die geïnteresseerd is in opslag, verwerking of data analyse. Met de exponentiële groei van gegevens in de huidige digitale wereld is het essentieel om deze gegevens efficiënt te kunnen bevragen, manipuleren en analyseren. SQL is de standaardtaal voor relationele databasemanagementsystemen en stelt gebruikers in staat om op een eenvoudige en efficiënte manier met databases om te gaan. Kennis van SQL stelt dataprofielen in staat om zinvolle inzichten te halen uit grote datasets, gegevensanalyses uit te voeren en gegevens in te voeren in hun modellen voor machine learning. Inzicht in SQL opent mogelijkheden in data-analyse, data-engineering en daarbuiten, waardoor het een essentiële vaardigheid is voor elk aspirant-dataprofiel."
  },
  {
    "objectID": "sql_course/index_sql.html#chapters",
    "href": "sql_course/index_sql.html#chapters",
    "title": "SQL Course",
    "section": "Chapters",
    "text": "Chapters\n\nIntroduction to SQL and Databases\nOverview of SQL, databases, and how they are used in data science.\n\n\n\nBasic SQL Queries\nLearning SELECT statements, filtering data with WHERE clauses.\n\n\n\nWorking with Multiple Tables\nIntroduction to JOIN operations and their importance.\n\n\n\nAdvanced Data Manipulation\nUsing GROUP BY, HAVING, and aggregate functions.\n\n\n\nSubqueries, Nested Queries and Views\nEnhancing queries with subqueries for complex data retrieval.\n\n\n\nEach chapter is a step on your journey to mastering SQL. Let’s embark on this learning adventure together."
  },
  {
    "objectID": "sql_course/1_introduction.html#hr-sample-data",
    "href": "sql_course/1_introduction.html#hr-sample-data",
    "title": "Introduction SQL",
    "section": "HR sample data",
    "text": "HR sample data\nHere we will use a sample Database called HR that manages the HR data of the small businesses which is collected from www.sqltutorial.org. And to create the database, a SQLite script file was used when rendering the document. Read the extension docs for details."
  },
  {
    "objectID": "sql_course/1_introduction.html#erd-of-hr-database",
    "href": "sql_course/1_introduction.html#erd-of-hr-database",
    "title": "Introduction SQL",
    "section": "ERD of HR database",
    "text": "ERD of HR database\nThe following database diagram illustrates the HR sample database:\n\nFigure 1: ERD of HR database"
  },
  {
    "objectID": "sql_course/1_introduction.html#editable-example",
    "href": "sql_course/1_introduction.html#editable-example",
    "title": "Introduction SQL",
    "section": "Editable Example",
    "text": "Editable Example\nAnd now, you can run all sort of queries from the tables of the HR databases.\n\nselect * from regions;"
  },
  {
    "objectID": "sql_course/1_introduction.html#not-editable-example",
    "href": "sql_course/1_introduction.html#not-editable-example",
    "title": "Introduction SQL",
    "section": "Not editable example",
    "text": "Not editable example\nYou can also create “not-editable” code chunk (that is, you simply can run the query but won’t be able to edit/modify it) for HR database. And to do this, just use another instance of database under the database key in the yaml with a different name and use the option editable: false."
  },
  {
    "objectID": "sql_course/1_introduction.html#not-editable-example-1",
    "href": "sql_course/1_introduction.html#not-editable-example-1",
    "title": "Introduction SQL",
    "section": "Not editable example",
    "text": "Not editable example\n\nselect * from employees;"
  },
  {
    "objectID": "sql_course/1_introduction.html",
    "href": "sql_course/1_introduction.html",
    "title": "Introductie SQL",
    "section": "",
    "text": "https://dannyvolkaerts.github.io/\nManier van werken: 1. EERD graag afdrukken of naast je houden op ander scherm 2. Interactie via Wooclap -&gt; ik ben mee met het verhaal of niet, eventueel enkele tussenvragen om te pijlen hoe ze mee zijn\nOefeningen via Azure Data Studio: New connection - Microsoft SQL Server\nI created two databases DV_first_group and DV_second_group in the database. Here are the login details :\n\nExtentions links - MySQL -&gt; installeren\n\n\n\n\nSQL (Structured Query Language) is de standaard taal om te communiceren met relationele databases. Ze wordt gebruikt voor insert, search, update en delete functionaliteiten.\n\nData opvragen: SQL laat toe om efficient data op te vragen uit de database.\nData Manipulatie: Wijzigen van de data\nData Integriteit: Het onderhouden van de accuraatheid en betrouwbaarheid van de database.\n\nOntwikkeld door IBM (1974)\n\n\n\n\n\nEen relationele database slaat gegevens op in tabellen\nGegevens worden georganiseerd in rijen en kolommen\nVoorbeelden zijn MySQL, PostgreSQL, MS SQL en SQLite\n\n\nverschil tussen database zelf en clients Azure Data Studio = client MySQL workbench = client PG Admin = client\n\n\n\n\n\n\nTabellen: Informatie opslaan in rijen en kolommen\nQueries: Het ophalen of toevoegen van data op basis van specifieke criteria\nSchemas: Weergeven van de structuur van de database\n\n\n\n\n\n\nData analist: gebruikt SQL om databases te doorzoeken en inzichten te extraheren.\nData engineer: ontwerpt en onderhoudt databasemanagementsystemen, gebruikt SQL om datapijplijnen te creëren.\nData scientist: gebruikt SQL om gegevens voor te bereiden en op te schonen voor analyse.\nDatabaseontwikkelaar: creëert en optimaliseert databases, schrijft stored procedures en complexe queries."
  },
  {
    "objectID": "sql_course/1_introduction.html#inleiding-tot-sql-and-databases",
    "href": "sql_course/1_introduction.html#inleiding-tot-sql-and-databases",
    "title": "Introductie SQL",
    "section": "",
    "text": "https://dannyvolkaerts.github.io/\nManier van werken: 1. EERD graag afdrukken of naast je houden op ander scherm 2. Interactie via Wooclap -&gt; ik ben mee met het verhaal of niet, eventueel enkele tussenvragen om te pijlen hoe ze mee zijn\nOefeningen via Azure Data Studio: New connection - Microsoft SQL Server\nI created two databases DV_first_group and DV_second_group in the database. Here are the login details :\n\nExtentions links - MySQL -&gt; installeren\n\n\n\n\nSQL (Structured Query Language) is de standaard taal om te communiceren met relationele databases. Ze wordt gebruikt voor insert, search, update en delete functionaliteiten.\n\nData opvragen: SQL laat toe om efficient data op te vragen uit de database.\nData Manipulatie: Wijzigen van de data\nData Integriteit: Het onderhouden van de accuraatheid en betrouwbaarheid van de database.\n\nOntwikkeld door IBM (1974)\n\n\n\n\n\nEen relationele database slaat gegevens op in tabellen\nGegevens worden georganiseerd in rijen en kolommen\nVoorbeelden zijn MySQL, PostgreSQL, MS SQL en SQLite\n\n\nverschil tussen database zelf en clients Azure Data Studio = client MySQL workbench = client PG Admin = client\n\n\n\n\n\n\nTabellen: Informatie opslaan in rijen en kolommen\nQueries: Het ophalen of toevoegen van data op basis van specifieke criteria\nSchemas: Weergeven van de structuur van de database\n\n\n\n\n\n\nData analist: gebruikt SQL om databases te doorzoeken en inzichten te extraheren.\nData engineer: ontwerpt en onderhoudt databasemanagementsystemen, gebruikt SQL om datapijplijnen te creëren.\nData scientist: gebruikt SQL om gegevens voor te bereiden en op te schonen voor analyse.\nDatabaseontwikkelaar: creëert en optimaliseert databases, schrijft stored procedures en complexe queries."
  },
  {
    "objectID": "sql_course/1_introduction.html#sql-in-actie",
    "href": "sql_course/1_introduction.html#sql-in-actie",
    "title": "Introductie SQL",
    "section": "SQL in actie",
    "text": "SQL in actie\n\n\nERD van Human Resources database\nDatabase diagram: HR voorbeeld database: \n\n\n\n\n\n\nFigure 1: ERD van HR database\n\n\n\n\nERD: Entity-relationship diagram\n\nEntiteit: object/iets waarvan gegevens verzameld worden in 1 tabel\n\nPrimaire sleutel: veld of groep velden die uniek zijn voor elk record\n\nRelatietypes (kardinaliteit): het maximaal aantal keren dat een instantie in één entiteit kan relateren met instanties in een andere entiteit\n\nVreemde sleutel (foreign key): een verzameling velden van een tabel die dient als verwijzing naar een andere tabel\n\n\n\n\n\n\nERD concept\n\nEntiteit: object/iets waarvan gegevens verzameld worden in 1 tabel\nPrimaire sleutel: veld of groep velden die uniek zijn voor elk record\nRelatietypes (kardinaliteit): het maximaal aantal keren dat een instantie in één entiteit kan relateren met instanties in een andere entiteit\nVreemde sleutel (foreign key): een verzameling velden van een tabel die dient als verwijzing naar een andere tabel\n\n\n\n\nQuery voorbeeld\n\nSELECT *\nFROM regions;\n\n\n\n\nAnder Query voorbeeld\n\nSELECT * \nFROM employees \nLIMIT 5;\n\n\nLIMIT is al een soort dialect -&gt; bijvoorbeeld in sql server: SELECT TOP(5) * FROM"
  },
  {
    "objectID": "sql_course/5_subqueries.html",
    "href": "sql_course/5_subqueries.html",
    "title": "Subqueries & Views",
    "section": "",
    "text": "Subquery\nPer definitie is een subquery een query die in een andere query wordt genest.\n\nStel dat je alle werknemers moet vinden die zich bevinden op de locatie met id 1700.\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n\nSubquery\nDan zoeken we eerst alle departementen op locatie 1700:\n\nSELECT *\nFROM departments\nWHERE location_id = 1700;\n\n\n\n\nSubquery\nDan gebruiken we deze lijst om de werknemers te vinden:\n\nSELECT employee_id, first_name, last_name\nFROM employees\nWHERE department_id IN (1 , 3, 9, 10, 11)\nORDER BY first_name , last_name;\n\n\nSELECT employees.*,location_id\nFROM departments INNER JOIN employees USING(department_id)\nWHERE location_id = 1700;\n\n\n\n\n\nSubquery\n\nProbleem: lijst met department_id’s kan heel lang zijn\n\nProbleem 2: omslachtig wanneer we werknemers uit ander departement willen\n\n\n\n\nSubquery\n\nSELECT employee_id, first_name, last_name\nFROM employees\nWHERE department_id IN (\n        SELECT department_id\n        FROM departments\n        WHERE location_id = 1700)\nORDER BY first_name , last_name;\n\n\nDe query tussen haakjes wordt een subquery genoemd. Het wordt ook wel een inner query of inner select genoemd.\nDe query die de subquery bevat, wordt een outer query of outer select genoemd.\n\n\n\n\nSubquery voorbeeld 1\nVind de werknemers met het hoogste salaris:\n\nSELECT employee_id, first_name, last_name, salary\nFROM employees\nWHERE salary = (SELECT MAX(salary) FROM employees)\nORDER BY first_name , last_name;\n\n\n\n\nSubquery voorbeeld 2\nWat is de vraagstelling bij volgende query?\n\nSELECT employee_id, first_name, last_name, salary\nFROM employees\nWHERE salary &gt;= (\n  SELECT MAX(min) FROM (\n    SELECT MIN(salary) as min \n    FROM employees GROUP BY department_id))\nORDER BY first_name , last_name;\n\n\nGeef me de werknemers die een salaris hebben gelijk aan of hoger dan het hoogste minimum van een van de departementen.\n\n\n\n\nOpgelet!\nDe ALL operator vergelijkt een waarde met elke waarde van de resultaattabel.\nGeef alle spelers van Rijswijk die een bondsnr hebben dat kleiner is dan het kleinste bondsnr van de spelers van Den Haag:\n\n-- onderstaande werkt niet in deze browser! -&gt; uit te voeren in SQL server\nselect *\nfrom SPELERS\nwhere PLAATS = 'Rijswijk' AND BONDSNR &lt; ALL(\nselect BONDSNR from spelers\nwhere PLAATS = 'Den Haag'\n)\n\n\nselect naam, plaats, bondsnr\nfrom SPELERS\nwhere PLAATS = ‘Rijswijk’\n\nselect naam, plaats, bondsnr\nfrom SPELERS\nwhere PLAATS = ‘Den Haag’\n\nin sqlite moet het via:\nselect MIN(BONDSNR)\nfrom SPELERS\nwhere PLAATS = ‘Den Haag’\n\nin subquery moet het zijn:\nselect bondsnr\nfrom SPELERS\nwhere PLAATS = ‘Den Haag’\nAND BONDSNR IS NOT NULL\n\nWat als ik ALL verander in ANY?\nDe ANY operator vergelijkt een waarde met elke waarde in een tabel en is voldaan als de vergelijking minstens voor één waarde uit de tabel geldt.\nselect *\nfrom SPELERS\nwhere PLAATS = ‘Rijswijk’ AND BONDSNR &lt; ANY(\nselect BONDSNR from spelers\nwhere PLAATS = ‘Den Haag’\n)\n\n\n\n\n\nCorrelated subquery\nIn tegenstelling tot een gewone subquery, is een gecorreleerde subquery een subquery die de waarden van de buitenste query gebruikt. Een gecorreleerde subquery kan ook één keer geëvalueerd worden voor elke rij die geselecteerd wordt door de buitenste query. Hierdoor kan een query die een gecorreleerde subquery gebruikt traag zijn.\n\n\n\nCorrelated subquery voorbeeld\nDe volgende query vindt alle werknemers waarvan het salaris hoger is dan het gemiddelde salaris van de werknemers in hun afdeling\n\nSELECT employee_id, first_name, last_name, salary, department_id\nFROM employees e\nWHERE salary &gt; (    SELECT AVG(salary)\n                    FROM employees\n                    WHERE department_id = e.department_id)\nORDER BY department_id, first_name, last_name;\n\n\n\n\nCorrelated subquery voorbeeld\nDe volgende query geeft de werknemers en het gemiddelde salaris van alle werknemers in hun afdelingen:\n\nSELECT employee_id, first_name, last_name, department_name,salary,\n    (SELECT ROUND(AVG(salary),0) FROM employees\n     WHERE department_id = e.department_id) avg_salary_in_department\nFROM employees e INNER JOIN departments d ON d.department_id = e.department_id\nORDER BY department_name, first_name, last_name;\n\n\n\n\nVIEWs\nEen view is als een virtuele tabel die geproduceerd wordt door het uitvoeren van een query. Het relationele databasebeheersysteem (RDBMS) slaat een view op als een SELECT met naam in de databasecatalogus.\nTelkens wanneer je een SELECT opdracht geeft die een view naam bevat, voert de RDBMS de view-definiërende query uit om de virtuele tabel te creëren. Die virtuele tabel wordt dan gebruikt als brontabel van de query.\n\n\n\nVIEWs\nGebruik: Views helpen je om de gegevens voor een specifieke groep gebruikers in te pakken. Je kunt bijvoorbeeld een overzicht maken van salarisgegevens voor de medewerkers van de afdeling Financiën.\nViews helpen databasebeveiliging te handhaven. In plaats van gebruikers toegang te geven tot databasetabellen, maak je een view om alleen noodzakelijke gegevens te onthullen en geef je gebruikers toegang tot de view.\n\nCREATE VIEW view_name \nAS\nSELECT-statement\n\n\n\n\nVIEWs voorbeeld\n\nCREATE VIEW employee_contacts AS\n    SELECT first_name, last_name, email, phone_number, department_name\n    FROM employees e INNER JOIN\n        departments d ON d.department_id = e.department_id\n    ORDER BY first_name;\n\n\nSELECT * FROM employee_contacts;\n\n\n\n\nVIEWs voorbeeld 2\n\nCREATE VIEW payroll (first_name , last_name , job, compensation) AS\n    SELECT \n        first_name, last_name, job_title, salary\n    FROM\n        employees e\n            INNER JOIN\n        jobs j ON j.job_id= e.job_id\n    ORDER BY first_name;\n\n\nSELECT\njob,\nMIN(compensation),\nMAX(compensation),\nAVG(compensation)\nFROM\npayroll\nWHERE\njob LIKE ‘A%’\nGROUP BY job;\n\n\n\n\n\ndrop VIEW\n\nDROP VIEW view_name;\n\n\n\n\nOefeningen"
  },
  {
    "objectID": "sql_course/2_basics.html",
    "href": "sql_course/2_basics.html",
    "title": "Basis van SQL",
    "section": "",
    "text": "Topics\n\nBasisstructuur SQL queries\nSELECT statement om kolommen te halen van tabellen\nWHERE clausule om rijen te filteren\nSorteren van het resultaat met ORDER BY\n\n\n\n\nBasisstructuur\n\n\n\n\n\n\n\nQuery\nUitvoering\n\n\n\n\nSELECT\nFROM\nWHERE\nGROUP BY\nHAVING\nORDER BY\n\nFROM\nWHERE\nGROUP BY\nHAVING\nSELECT\nORDER BY\n\n\n\n\n\n\n\nSELECT Statement\nDe SELECT-instructie wordt gebruikt om gegevens uit een database te selecteren. De geretourneerde gegevens worden opgeslagen in een resultatentabel, ook wel de result-set genoemd.\nSELECT column1, column2 \nFROM table_name;\n\n\n\nSELECT *\nDe ‘*’ instructie wordt gebruikt om de volledige inhoud van de tabel te bekijken.\n\nSELECT * \nFROM regions;\n\n\nvoorbeeld met kolommen\nWijzigen kolomnamen in resultaat: ‘as’\nORDER BY: std ASC, expliciet: DESC, kan met aliassen\n\n\n\n\nWHERE Statement\nDe WHERE-statement wordt gebruikt om specifieke rijen te selecteren die voldoen aan één of meerdere voorwaarden.\n\nVoorbeeld: ik wil de werknemers (employees) met een salaris hoger dan 16000 euro.\n\nSELECT * \nFROM employees\nWHERE salary &gt; 16000;\n\n\nfirst_name as voornaam, last_name as achternaam, salary as salaris\n\n\n\n\nWHERE voorbeeld\nIk wil een overzicht van de werknemers (employees) die werken in het IT departement.\n\n-- we zoeken eerst de code voor het IT-departement\nSELECT *\nFROM departments;\n-- daarna zoeken we de werknemers die binnen dit departement werken\nSELECT first_name, last_name, department_id\nFROM employees\nWHERE department_id = '6';\n\n\nrijfilter, conditie per rij\n\n\n\n\nWHERE - combineren\nCombineren van filters kan met ‘AND’, ‘OR’, ‘NOT’\nVoorbeeld: Ik zoek de werknemers (employees) die werken in het IT departement EN een salaris hebben lager dan 18000 euro.\n\nSELECT first_name, last_name, department_id, salary\nFROM employees\nWHERE department_id = '6' \nAND salary &lt; 18000;\n\n\n\n\nWHERE - operatoren\n\n\n\n=\n!=\n&lt;&gt;\n&gt;=\n&gt;\n\n\nIN\nLIKE\nIS NULL\nIS NOT NULL\n\n\n\nBETWEEN… AND…\n\n\n\n\n\n\n\n\n\n\n\n\n\nAND\nOR\nNOT\n\n\n\n\n\n\nSELECT first_name, last_name, salary\nFROM employees\nWHERE last_name LIKE 'Ma%'\n\n\nSELECT *\nFROM employees\nWHERE phone_number IS NULL\n\n\n\n\n\nSELECT DISTINCT\n\nSELECT DISTINCT salary\nFROM employees\n\n\nbeperken van dubbele rijen: ‘distinct’ (altijd vlak achter SELECT, voor alle kolommen toegepast)\n\n\n\n\n\nSELECT functies\n\n\n\nOperatie\nDefinitie\n\n\n\n\nCOUNT\nAantal lijnen\n\n\nAVG\nGemiddelde van de waarden\n\n\nSUM\nSom van de waarden\n\n\nMIN / MAX\nMinimum / Maximum waarde\n\n\n\n\n\n\nSELECT functies voorbeeld\nHoeveel werknemers in het IT departement?\n\nSELECT department_id, count(*)\nFROM employees\nWHERE department_id = '6' \n\n\nSELECT department_id\nFROM employees\nWHERE department_id = ‘6’\n\nSELECT department_id, count(*) as aantal\nFROM employees\nWHERE department_id = ‘6’\n\nLIMIT\nof TOP\n\n\n\n\n\nOefeningen"
  },
  {
    "objectID": "sql_course/4_advanced.html",
    "href": "sql_course/4_advanced.html",
    "title": "Advanced Data Manipulatie",
    "section": "",
    "text": "Inhoud\n\nAggregatie functies\n\nGROUP BY\n\nHAVING\n\nFuncties (tekst, numeriek, datum/tijd)\n\n\n\n\n\nAggregatie functies\n\n\n\nOperatie\nDefinitie\n\n\n\n\nCOUNT\nAantal lijnen\n\n\nAVG\nGemiddelde van de waarden\n\n\nSUM\nSom van de waarden\n\n\nMIN / MAX\nMinimum / Maximum waarde\n\n\n\n\n\n\nAggregatie functies voorbeeld\nGemiddelde salaris van de werknemers:\n\nSELECT AVG(salary) as 'gemiddelde salaris'\nFROM employees;\n\n\nMAX MIN\n\n\n\n\nGROUP BY\n\nDefinitie: De GROUP BY-clausule is een optionele clausule van de SELECT-instructie. Met de GROUP BY clausule kun je rijen groeperen op basis van de waarden van een of meer kolommen. Voor elke groep wordt één rij geretourneerd.\nGebruik: Maken van samenvattingen\n\nSELECT column1, column2, aggregate_function(column3)\nFROM table_name\nGROUP BY\n  column1,\n    column2;\n\n\n\nGROUP BY voorbeeld\nTellen van het aantal werknemers per departement\n\nSELECT department_id, COUNT(employee_id) headcount\nFROM employees\nGROUP BY department_id;\n\n\nWe willen de departementsnaam erbij:\nSELECT\ndepartment_name,\nCOUNT(employee_id) headcount\nFROM\nemployees e\nINNER JOIN departments d ON d.department_id = e.department_id\nGROUP BY\nd.department_id;\n\nWe willen geordend per headcount:\nORDER BY headcount DESC;\n\n\n\n\n\nGROUP BY voorbeeld 2\nDefinieer de vraagstelling van deze query:\n\nSELECT department_name, job_title, COUNT(employee_id)\nFROM employees e  INNER JOIN departments d ON d.department_id = e.department_id\n                  INNER JOIN jobs j ON j.job_id = e.job_id\nGROUP BY department_name, job_title;\n\n\nHet aantal werknemers per job per departement:\n\n\n\n\nHAVING\n\nDefinitie: voorwaarden te filteren die op de resultaten van aggregatiefuncties van toepassing zijn. Terwijl de WHERE-clausule wordt gebruikt om rijen te filteren voordat aggregatie plaatsvindt, wordt HAVING gebruikt om rijen te filteren na de aggregatie.\nGebruik: Essentieel in gevallen waar je voorwaarden wilt toepassen op groepen van data die door de GROUP BY-clausule zijn verzameld.\n\nSELECT column1, column2, AGGREGATE_FUNCTION (column3)\nFROM table1\nGROUP BY column1, column2\nHAVING group_condition;\n\n\n\nHAVING voorbeeld\nWe willen de managers en het aantal werknemers die aan hen direct rapporteren:\n\nSELECT e.manager_id, m.first_name,m.last_name, COUNT(e.employee_id) direct_reports\nFROM employees e INNER JOIN employees m on e.manager_id = m.employee_id\nWHERE e.manager_id IS NOT NULL\nGROUP BY e.manager_id,m.first_name,m.last_name\n\n\nManagers met minstens 5 werknemers die direct aan hun rapporteren:\n\nHAVING COUNT(e.employee_id) &gt;= 5\n\n\n\n\nHAVING voorbeeld 2\nTotale salaris voor elk departement (met een totale salaris tussen de 20k en 30k): Vul aan!\n\nSELECT department_id, SUM(salary) as totaal\nFROM employees\nGROUP BY department_id\nORDER BY SUM(salary);\n\n\nHAVING SUM(salary) BETWEEN 20000 AND 30000\nORDER BY SUM(salary);\n\n\n\n\n\nJullie kunnen nu een eenvoudige VOLLEDIGE query uitvoeren!\n\n\n\nFuncties\n\n\n\nText functies\nLet op dialect!\nSql server: Download PDF file.\n\n\n\nText functies\nLet op dialect!\nMySQL: Download PDF file.\n\n\n\nText functies voorbeeld\n\nSELECT LOWER(department_name)\nFROM departments\nORDER BY LOWER(department_name);\n\n\n\n\nText functies voorbeeld 2\n\nUPDATE employees \nSET email = UPPER(email);\n\n\n\n\nCASE functie\nWerkverjaardagen:\n\nSELECT first_name, last_name, hire_date,\n    --CASE (2000 - YEAR(hire_date))\n    CASE (2024 - strftime('%Y',hire_date))\n        WHEN 1 THEN '1 jaar'\n        WHEN 10 THEN '10 jaar'\n        WHEN 20 THEN '20 jaar'\n        WHEN 30 THEN '30 jaar'\n    END as verjaardag\nFROM\n    employees\nORDER BY first_name;\n\n\n\n\nSEARCHED CASE\nCASE\nWHEN boolean_expression_1 THEN\n    result_1\nWHEN boolean_expression_2 THEN\n    result_2\nWHEN boolean_expression_3 THEN\n    result_3\nELSE\n    else_result\nEND;\n\nboolean = True or False\n\n\n\n\nSEARCHED CASE voorbeeld\n\nSELECT first_name, last_name,salary,\n    CASE\n        WHEN salary &lt; 3000 THEN 'Low'\n        WHEN salary &gt;= 3000 AND salary &lt;= 5000 THEN 'Average'\n        WHEN salary &gt; 5000 THEN 'High'\n    END evaluation\nFROM\n    employees;\n\n\n\n\nOefeningen"
  },
  {
    "objectID": "sql_course/index_sql.html#hoofdstukken",
    "href": "sql_course/index_sql.html#hoofdstukken",
    "title": "SQL Cursus",
    "section": "Hoofdstukken",
    "text": "Hoofdstukken\n\nInleiding tot SQL en databases\nOverzicht van SQL, databases en hoe ze worden gebruikt in data science.\n\n\n\nBasis SQL Queries  Leren van SELECT statements en filteren van data met WHERE clauses.\n\n\n\nWerken met combineren van tabellen\nIntroductie tot JOIN operaties en hun belang.\n\n\n\nGeavanceerde Data Manipulatie\nGebruik van GROUP BY, HAVING en aggregatiefuncties.\n\n\n\nSubqueries, geneste Queries en Views\nUitbreiding van queries met subqueries voor complexere data opvraging.\n\n\n\nData Definition Language (DDL) & Data Manipulation Language (DML)\nBegrijpen hoe een databank gemaakt wordt en invoegen, updaten en deleten van data in de databank.\n\n\n\nSQL en PowerBI\nKennis halen uit data door het bundelen van de kracht van SQL met PowerBI.\n\n\n\nOefeningen H1 en H2\nOefeningen hoofstuk 1 en 2.\n\n\n\nOefeningen H3\nOefeningen hoofstuk 3 - joins.\n\n\n\nOefeningen H4\nOefeningen hoofstuk 4 - GROUP BY, HAVING,…\n\n\n\nOefeningen H5\nOefeningen hoofstuk 5 - subqueries\n\n\n\nOefeningen H6\nOefeningen DDL - de fietswinkel"
  },
  {
    "objectID": "sql_course/7_powerbi.html#waarom-powerbi-en-sql---belang-van-data-intelligentie",
    "href": "sql_course/7_powerbi.html#waarom-powerbi-en-sql---belang-van-data-intelligentie",
    "title": "Integratie van SQL in PowerBI",
    "section": "",
    "text": "PowerBI en SQL vormen een krachtige combinatie voor data-analyse en business intelligence.\nPowerBI stelt gebruikers in staat om data vanuit SQL visueel te verkennen en interactieve rapporten te creëren.\n\n\n\n\n\nSamen stellen ze organisaties in staat om:\n\nDiepgaande Inzichten te Verkrijgen: Gebruik SQL voor complexe dataverwerking en -analyse voordat je deze visualiseert in PowerBI.\nSnellere Besluitvorming: Door realtime toegang tot bijgewerkte data-analyses en rapportages.\nVerbeterde Data Governance: SQL helpt bij het structureren van data terwijl PowerBI zorgt voor de compliance en veiligheid bij het delen van rapporten."
  },
  {
    "objectID": "sql_course/7_powerbi.html#concept-en-werkwijze",
    "href": "sql_course/7_powerbi.html#concept-en-werkwijze",
    "title": "Integratie van SQL in PowerBI",
    "section": "Concept en Werkwijze",
    "text": "Concept en Werkwijze\n\nIntegratie van SQL in PowerBI gebeurt typisch via DirectQuery of door het importeren van data. Dit stelt gebruikers in staat om:\n\nDirectQuery: Verbind direct met SQL-databases voor realtime updates. Wijzigingen in de database worden onmiddellijk weerspiegeld in PowerBI-rapporten.\nData Importeren: Haal data uit SQL-databases naar PowerBI, waar het kan worden getransformeerd, gemodelleerd, en geanalyseerd."
  },
  {
    "objectID": "sql_course/7_powerbi.html#voorbeelden-van-powerbi-en-sql",
    "href": "sql_course/7_powerbi.html#voorbeelden-van-powerbi-en-sql",
    "title": "Integratie van SQL in PowerBI",
    "section": "Voorbeelden van PowerBI en SQL",
    "text": "Voorbeelden van PowerBI en SQL\n\n\nCase Studie 1: Verkoopanalyse\n\nSQL Query: Selecteer maandelijkse verkoopcijfers per productcategorie.\nPowerBI Dashboard: Visualiseer trends en patronen in verkoop over tijd met interactieve grafieken.\n\n\n\n\nCase Studie 2: Klantgedrag Analyse\n\nSQL Query: Analyseer klantinteracties en koopgedrag.\nPowerBI Rapport: Maak segmentatie van klanten en analyseer de effectiviteit van marketingcampagnes.\n\n\n\n\nDemo"
  },
  {
    "objectID": "sql_course/8_exercises.html#de-tennisvereniging",
    "href": "sql_course/8_exercises.html#de-tennisvereniging",
    "title": "Oefeningen hoofdstuk 1 en 2: tennis",
    "section": "",
    "text": "Algemene info over dit database schema kan je hier vinden.\n\n\n\nWatterson, Calvin and Hobbes"
  },
  {
    "objectID": "sql_course/Tennis_uitleg.html",
    "href": "sql_course/Tennis_uitleg.html",
    "title": "De Tennisvereniging",
    "section": "",
    "text": "Database schema\n\n\n\nBelangrijke informatie bij de tennis database\nDe tennisvereniging is opgericht in 1970 en vanaf het begin wordt een aantal administratieve gegevens in een database opgeslagen. Deze database bestaat uit de volgende tabellen: spelers, teams, wedstrijden, boetes en bestuursleden.\n\nDe spelerstabel bevat gegevens over spelers die lid zijn van de tennisvereniging, zoals namen, adressen en geboortedatums. Toetreding tot de vereniging vindt altijd plaats op 1 januari van een bepaald jaar. Spelers kunnen dus niet midden in een jaar lid worden. De spelerstabel bevat geen historische gegevens. Als een speler zijn of haar lidmaatschap opzegt, verdwijnt hij of zij uit de tabel. Ook bij eventuele verhuizingen wordt het oude adres overschreven met het nieuwe adres, het oude adres wordt dus nergens bewaard.\n\nDe tennisvereniging kent twee soorten leden: recreatiespelers en wedstrijdspelers. De eerste groep speelt alleen onderlinge wedstrijden, dus geen wedstrijden tegen spelers van andere verenigingen. De resultaten van de onderlinge wedstrijden worden niet geregistreerd. Wedstrijdspelers spelen in teamverband tegen spelers van andere verenigingen. De resultaten van deze wedstrijden worden wel bijgehouden. Elke speler heeft een uniek nummer, ongeacht of deze wedstrijdspeler is of niet. Dit spelersnummer wordt door de vereniging uitgedeeld. Het is verplicht dat elke wedstrijdspeler bij de tennisbond geregistreerd staat.\n\nDe bond, die een nationaal instituut is, geeft elke wedstrijdspeler een uniek bondsnummer. Dit bondsnummer bestaat meestal uit cijfers, maar kan ook letters bevatten. Als een wedstrijdspeler geen wedstrijden meer speelt, maar recreatiespeler wordt, vervalt het bondsnummer. Let wel, recreatiespelers hebben dus geen bondsnummer, maar wel een spelersnummer.\n\nDe tennisvereniging heeft een aantal teams dat meedoet in competities. Voor elk team worden de aanvoerder en de divisie waarin het team op dat moment uitkomt, geregistreerd. De aanvoerder hoeft geen wedstrijden voor het team gespeeld te hebben. Het zou kunnen dat een bepaalde speler op een bepaald moment aanvoerder van twee of meer teams is. Ook in deze tabel wordt geen historie bijgehouden. Bij promotie of degradatie van een team naar een andere divisie wordt de geregistreerde divisie eenvoudigweg overschreven. Hetzelfde geldt voor de aanvoerder van een team: bij wisseling wordt het nummer van de oude aanvoerder overschreven.\n\nEen team bestaat uit een aantal spelers. Als een team tegen een team van een andere vereniging speelt, speelt elke speler van dat team een wedstrijd tegen een speler van het andere team (we gaan voor het gemak ervan uit dat wedstrijden waarbij koppels tegen elkaar spelen niet voorkomen). Het team waarvan de meeste spelers hun wedstrijd winnen is winnaar.\n\nEen team bestaat niet altijd uit dezelfde groep spelers. Bij ziekte of vakanties zijn soms invallers nodig. Een speler kan dus voor meerdere teams uitkomen. Als we spreken over ‘de spelers van een team’, dan bedoelen we dus de spelers die minstens één wedstrijd voor het team gespeeld hebben. Nogmaals, alleen spelers met een bondsnummer mogen officiële wedstrijden spelen.\n\nEen tenniswedstrijd is opgebouwd uit een aantal sets. Degene die de meeste sets heeft gewonnen is winnaar. Voor elke wedstrijd wordt vooraf bepaald bij hoeveel gewonnen sets de wedstrijd gewonnen is. Over het algemeen wordt de wedstrijd gestopt als een van de twee spelers twee of drie sets gewonnen heeft. Mogelijke eindstanden van een tenniswedstrijd zijn dus 2-1 of 2-0 als gespeeld wordt totdat een van de spelers twee sets gewonnen heeft (best of three), of 3-2, 3-1 of 3-0 als gespeeld wordt tot drie gewonnen sets (best of five). Een speler kan zijn of haar wedstrijd winnen of verliezen, gelijkspel is niet mogelijk. In de wedstrijdentabel wordt voor elke wedstrijd apart bijgehouden welke speler de wedstrijd heeft gespeeld en voor welk team. Tevens wordt geregistreerd hoeveel sets de speler heeft gewonnen en verloren. Hieruit is af te leiden of hij of zij de wedstrijd gewonnen heeft.\n\nVoor onreglementair gedrag van spelers (te late opkomst, agressief gedrag of niet verschijnen) worden door de bond boetes opgelegd. Boetes worden door de vereniging betaald. Na betaling worden ze in de boetestabel geregistreerd. Zolang een speler wedstrijden speelt, blijven alle boetes bewaard die voor hem of haar opgelegd en betaald zijn.\n\nAls een speler de vereniging verlaat, worden al zijn of haar gegevens in de vijf tabellen vernietigd. Als de vereniging een team terugtrekt, worden alle gegevens over dat team uit de teams- en wedstrijdentabel verwijderd. Als een wedstrijdspeler stopt met het spelen van wedstrijden en hij of zij dus weer recreant wordt, worden alle wedstrijd- en boetegegevens uit de desbetreffende tabellen verwijderd.\n\nSinds 1 januari 1990 wordt in de bestuursledentabel bijgehouden wie er in het bestuur zitten. Vier functies worden onderscheiden: voorzitter, penningmeester, secretaris en algemeen lid. Elk jaar op 1 januari wordt een nieuw bestuur gekozen. Wanneer een speler een bestuursfunctie bekleedt, worden de begin- en einddatum hiervan geregistreerd. Als iemand nog actief is, wordt er geen einddatum ingevuld.\n\n\n\nEnkele aandachtspunten\nIn het database schema willen we even wijzen op enkele punten:\n\nMerk op dat het spelersnummer een centrale rol in het schema heeft. Het is in één tabel de primaire sleutel en in de vier andere tabellen de externe sleutel (‘foreign key’).\n\nDe bestuursledentabel heeft een samengestelde primaire sleutel. In de figuur zie je dat aan de twee sleutelicoontjes, in de code staan er twee kolommen in de PRIMARY KEY.\n\nEen veelgemaakte fout is geen rekening houden met het feit dat het spelersnummer in de teamstabel het nummer is van de kapitein van een team. Om te weten wie effectief wedstrijden gespeeld heeft, moet je in de wedstrijdentabel het spelersnummer gebruiken."
  },
  {
    "objectID": "sql_course/8_exercises.html#basis-h1h2",
    "href": "sql_course/8_exercises.html#basis-h1h2",
    "title": "Oefeningen hoofdstuk 1 en 2: tennis",
    "section": "BASIS (H1,H2)",
    "text": "BASIS (H1,H2)\n\n\nOefening 1\nToon alle spelers uit Zoetermeer die lid werden van de club vóór 1984).\n\n\n\n\nSELECT spelersnr, naam || ’ ’ || voorletters AS naam, jaartoe\nFROM spelers\nWHERE plaats = ‘Zoetermeer’ AND jaartoe &lt; 1984\n\n\n\n\n\nOefening 2\nMaak een lijst van alle teams waarvoor lid nr 27 de kapitein is.\n\n\n\n\nSELECT *\nFROM teams\nWHERE spelersnr = 27\n\n\n\n\n\nOefening 3\nGeef een overzicht van alle gewonnen tenniswedstrijden.\n\n\n\n\nSELECT *\nFROM wedstrijden\nWHERE gewonnen &gt; verloren\n\n\n\n\n\nOefening 4\nGeef een overzicht van alle wedstrijden die speler 112 gespeeld heeft. Bereken voor elke van deze wedstrijden met hoeveel sets deze speler gewonnen of verloren heeft.\n\n\n\n\nSELECT wedstrijdnr, spelersnr, abs(gewonnen - verloren) AS verschil\nFROM wedstrijden WHERE spelersnr = 112\n\n\n\n\nOefening 5\nMaak een lijst van alle betaalde boetes.\n\n\n\n\nSELECT *\nFROM boetes\n\n\n\n\n\nOefening 6\nGeef het kleinste en grootste boetebedrag.\n\n\n\n\nSELECT min(bedrag) AS min, max(bedrag) AS max FROM boetes\n\n\n\n\nOefening 7\nMaak een lijst van alle vrouwelijke spelers die niet in Leiden wonen.\n\n\n\n\nSELECT spelersnr, naam, plaats, geslacht\nFROM spelers\nWHERE geslacht = ‘V’ AND plaats != ‘Leiden’\n\n\n\n\n\nOefening 8\nWat is het gemiddelde boetebedrag? Hoeveel boetes werden al betaald? Geef bij deze laatste de kolomnaam “Aantal boetes”\n\n\n\n\nSELECT round(avg(bedrag)) AS average, count(bedrag) AS “number of fines”\nFROM boetes\n\n\n\n\n\nOefening 9\nGeef lijst van alle spelers die een boete van meer dan € 30 kregen. We willen enkel een lijst van spelers en geen lijst van boetes. -Een speler die meer dan één boete kreeg (e.g. Cools heeft een boete van zowel € 75 als € 100) mag maar één keer voorkomen in deze lijst.\n\n\n\n\nSELECT DISTINCT spelersnr\nFROM boetes\nWHERE bedrag &gt; 30\n\n\n\n\n\nOefening 10\nGenereer een lijst van alle competitiespelers. Niet alle spelers van onze club spelen in een competitie, maar zij die wel in officiële wedstrijden spelen moeten lid zijn van de nationale bond\n\n\n\n\nSELECT spelersnr, naam\nFROM spelers\nWHERE bondsnr IS NOT null\n\n\n\n\n\nMOEILIJKER\n\n\n\nOefening 11\nMaak een overzicht waarbij je per woonplaats die minstens één letter ‘o’ (hoofdletter of kleine letter allebei OK) aangeeft hoeveel spelers er wonen in die gemeente. Sorteer op plaats.\n\n\n\n\nSELECT plaats, COUNT(*) AS aantal\nFROM spelers\nGROUP BY plaats\nHAVING LOWER(plaats) LIKE ‘%o%’\nORDER BY plaats;"
  },
  {
    "objectID": "sql_course/9_exercises_joins.html#de-tennisvereniging",
    "href": "sql_course/9_exercises_joins.html#de-tennisvereniging",
    "title": "Oefeningen hoofdstuk 3: tennis joins",
    "section": "",
    "text": "Algemene info over dit database schema kan je hier vinden.\n\n\n\nWatterson, Calvin and Hobbes"
  },
  {
    "objectID": "sql_course/9_exercises_joins.html#joins-h3",
    "href": "sql_course/9_exercises_joins.html#joins-h3",
    "title": "Oefeningen hoofdstuk 3: tennis joins",
    "section": "JOINS (H3)",
    "text": "JOINS (H3)\n\n\nOefening 1\nMaak een lijst van alle boetes en voeg de naam van de speler toe (naam en eerste letter(s) in één kolom).\n\n\n\n\nSELECT b.betalingsnr, b.spelersnr, s.naam || ’ ’ || s.voorletters AS naam, b.datum, b.bedrag\nFROM boetes b INNER JOIN spelers s ON b.spelersnr = s.spelersnr\n\nINDIEN namen van de join-kolommen gelijk zijn mag ook USING gebruikt worden:\nFROM boetes b INNER JOIN spelers s USING(spelersnr)\n\n\n\n\nOefening 2\nGeef een overzicht van alle bestuursleden die nu in functie zijn. Toon hun functie. Geef ook hun namen (naam en voorletters in één kolom).\n\n\n\n\nSELECT b.spelersnr, s.naam || ’ ’ || s.voorletters AS naam, b.begin_datum, b.functie\nFROM bestuursleden b INNER JOIN spelers s ON b.spelersnr = s.spelersnr\nWHERE eind_datum IS null\n\n\n\n\n\nOefening 3\nGeef een overzicht van alle boetes groter dan € 30. Toon het bedrag in eurocent. Geef ook het spelersnummer en de naam van de speler die de boete kreeg.\n\n\n\n\nSELECT b.spelersnr, s.naam, round(bedrag*100) AS “bedrag in centen”\nFROM boetes b INNER JOIN spelers s ON b.spelersnr = s.spelersnr AND bedrag &gt; 30\n\n\n\n\n\nOefening 4\nMaak een lijst van alle gewonnen wedstrijden gespeeld door leden van team 2. Toon het spelersnr van de winnende speler en ook het nummer van de kapitein van het team.\n\n\n\n\nSELECT w.wedstrijdnr, w.spelersnr, w.teamnr, t.spelersnr AS captain\nFROM wedstrijden w INNER JOIN teams t ON w.teamnr = t.teamnr\nWHERE w.teamnr = 2 AND gewonnen-verloren &gt; 0\n\n\n\n\n\nOefening 5\nToon naam en voorletters (in 1 kolom), team en divisie van de kapitein van elk team.\n\n\n\n\nSELECT t.teamnr,t.spelersnr, s.naam || ’ ’ || s.voorletters AS kapitein, t.divisie FROM teams t INNER JOIN spelers s ON t.spelersnr = s.spelersnr\n\n\n\n\nMOEILIJKER\n\n\n\nOefening 6\nGeef een lijst met het spelersnummer, de naam van de speler, de datum van de boete en het bedrag van de boete van al de spelers die een boete gekregen hebben met een bedrag groter dan € 45,50 en in Rijswijk wonen. Sorteer op spelersnr en het volgnummer van de boete.\n\n\n\n\nSELECT spelers.spelersnr, spelers.naam, boetes.datum, boetes.bedrag\nFROM spelers INNER JOIN boetes ON spelers.spelersnr = boetes.spelersnr\nWHERE boetes.bedrag &gt; 45.50 AND spelers.plaats = ‘Rijswijk’\nORDER BY spelers.spelersnr, boetes.betalingsnr;\n\n\n\n\n\nOefening 7\nGeef voor elke wedstrijd het wedstrijdnummer en de volledige naam van de aanvoerder van het team waarvoor de wedstrijd werd gespeeld. Sorteer je resultaat volgens het wedstrijdnummer in oplopende volgorde. TIP: je zal hier een JOIN moeten doen met meer dan twee tabellen.\n\n\n\n\nSELECT W.wedstrijdnr, T.spelersnr, naam, voorletters\nFROM wedstrijden W INNER JOIN teams T on W.teamnr = T.teamnr\nINNER JOIN spelers S on T.spelersnr = S.spelersnr\nORDER BY 1\n\n\n\n\n\nOefening 8\nGeef de nummers van de aanvoerders voor wie minstens één boete is betaald.\n\n\n\n\nSELECT t.spelersnr\nFROM teams as t, boetes as bt\nWHERE t.spelersnr = bt.spelersnr\n\nOok eens uitvoeren met SELECT spelersnr -&gt; amubiguous\n\n\n\n\n\nOefening 9\nGeef van elke wedstrijd het spelersnrummer, het teamnummer, de naam van de speler en de divisie van het team.\n\n\n\n\nSELECT DISTINCT w.spelersnr, w.teamnr, s.naam, t.divisie\nFROM wedstrijden as w, spelers as s, teams t\nWHERE w.spelersnr = s.spelersnr AND w.teamnr = t.teamnr\n\n\n\n\nOefening 10\nGeef het betalingsnr, spelersnr en de datum van elke boete die betaald is in het jaar waarin de betrokken speler tot de tennisvereniging is toegetreden.\n\n\n\n\nSQLite:\nSELECT b.betalingsnr, b.spelersnr, b.datum\nFROM boetes as b, spelers as s on b.spelersnr=s.spelersnr\nWHERE strftime(‘%Y’,b.datum) = s.jaartoe\n\nSQL server:\nSELECT b.betalingsnr, b.spelersnr, b.datum\nFROM boetes as b, spelers as s on b.spelersnr=s.spelersnr\nWHERE YEAR(b.datum) = s.jaartoe\n\nDUS niet per se enkel join op basis van de sleutelkolom maar kan ook bijkomende conditie zijn.\n\n\n\n\nOefening 11\nGeef het nummer van elke speler waarvoor op dezelfde dag dat hij bestuurslid is geworden een boete betaald is.\n\n\n\n\nSELECT DISTINCT bl.spelersnr\nFROM bestuursleden as bl, boetes as b\nWHERE bl.spelersnr = b.spelersnr\nAND bl.begin_datum = b.datum\n\n\n\n\n\nOefening 12\nGeef de nummers van de spelers die ouder zijn dan R.Permentier\n\n\n\n\nSELECT s.spelersnr\nFROM spelers as s, spelers as p WHERE p.naam = ‘Permentier’\nAND p.voorletters = ‘R’\nAND s.geb_datum &lt; p.geb_datum\n\n\n\n\nOefening 13\nGeef de nummers en de namen van de spelers die in dezelfde plaats wonen als de speler met nummer 27. Speler 27 behoort zelf in het eindresultaat voor te komen.\n\n\n\n\nSELECT s.spelersnr, s.naam\nFROM spelers as s, spelers as s27\nWHERE s.Plaats = s27.plaats\nAND s27.spelersnr = 27\n\nINDIEN speler 27 niet in resultaat mag voorkomen: AND s.spelersnr &lt;&gt; 27\n\n\n\n\n\nOefening 14\nGeef het nummer en de naam van elke wedstrijdspeler alsmede het nummer en de naam van de aanvoerder van elk team waarvoor die speler ooit gespeeld heeft; het resultaat mag geen wedstrijdspelers bevatten die zelf aanvoerder zijn van een team.\n\n\n\n\nSELECT DISTINCT S.SPELERSNR AS SPELERS_SPELERSNR,\nS.NAAM AS SPELERS_NAAM,\nAANV.SPELERSNR AS AANVOERDER_SPELERSNR,\nAANV.NAAM AS AANVOERDER_NAAM\nFROM SPELERS AS S, SPELERS AS AANV,\nWEDSTRIJDEN AS W, TEAMS AS T\nWHERE W.SPELERSNR = S.SPELERSNR\nAND T.TEAMNR = W.TEAMNR\nAND W.SPELERSNR &lt;&gt; T.SPELERSNR\nAND AANV.SPELERSNR = T.SPELERSNR\n\n\n\n\n\nOefening 15\nGeef de nummers van de boetes die qua boetebedrag gelijk zijn aan een boetebedrag behorende bij speler 44. Het resultaat dient niet de boetes van speler 44 te bevatten.\n\n\n\n\nSELECT B1.BETALINGSNR, B1.SPELERSNR\nFROM BOETES AS B1, BOETES AS B2\nWHERE B1.BEDRAG = B2.BEDRAG\nAND B2.SPELERSNR = 44\nAND B1.SPELERSNR &lt;&gt; 44\n\n\n\n\n\nOefening 16\nGeef van elke speler geboren na juni 1920 het spelersnummer, de naam en de boetebedragen die voor hem of haar betaald zijn.\n\n\n\n\nSELECT spelers.spelersnr, naam, bedrag\nFROM spelers, boetes\nWHERE spelers.spelersnr = boetes.spelersnr\nAND geb_datum &gt; ‘1920-06-30’\n\nEXPLICIET:\nSELECT spelers.spelersnr, naam, bedrag\nFROM spelers INNER JOIN boetes on spelers.spelersnr = boetes.spelersnr\nWHERE geb_datum &gt; ‘1920-06-30’\n\n\n\n\n\nOefening 17\nGeef voor alle spelers het spelersnr, de naam en de evetuele boetebedragen die voor hem of haar betaald zijn; sorteer op spelersnr.\n\n\n\n\nSELECT s.spelersnr, s.naam, b.bedrag\nFROM spelers s LEFT OUTER JOIN boetes b ON s.spelersnr = b.spelersnr ORDER BY 1\n\n\n\n\nOefening 18\nGeef van elke speler geboren in Rijswijk het spelersnr, de naam , de lijst met boetebedragen en de lijst met teams waarvoor hij of zij een wedstrijd heeft gespeeld.\n\n\n\n\nSELECT s.spelersnr, naam, bedrag, teamnr\nFROM spelers s LEFT OUTER JOIN boetes b USING(spelersnr)\nLEFT OUTER JOIN wedstrijden w on s.spelersnr = w.spelersnr\nWHERE plaats = ‘Rijswijk’"
  },
  {
    "objectID": "sql_course/10_exercises_advanced.html#de-tennisvereniging",
    "href": "sql_course/10_exercises_advanced.html#de-tennisvereniging",
    "title": "Oefeningen advanced",
    "section": "",
    "text": "Algemene info over dit database schema kan je hier vinden.\n\n\n\nWatterson, Calvin and Hobbes\n\n\n\n\n\n\nMaak een overzicht waarbij je per woonplaats aangeeft hoeveel spelers er wonen in die gemeente.Sorteer op plaats.\n\n\n\n\nSELECT plaats, COUNT(*) AS aantal\nFROM spelers\nGROUP BY plaats\nORDER BY plaats;\n\n\n\n\n\n\nGa na hoeveel mannelijke en hoeveel vrouwelijke spelers de club telt. Zorg ervoor dat je lijst gesorteerd wordt van het grootst aantal spelers naar het kleinste aantal.\n\n\n\n\nSELECT geslacht, COUNT(*) AS aantal\nFROM spelers\nGROUP BY geslacht\nORDER BY aantal DESC;\n\n\n\n\n\n\nGeef een lijst met het totaalbedrag aan boetes per speler. Sorteer het hoogste totale boetebedrag bovenaan.\n\n\n\n\nSELECT spelersnr, SUM(bedrag) AS totaalboetebedrag\nFROM boetes\nGROUP BY spelersnr\nORDER BY totaalboetebedrag DESC;\n\n\n\n\n\n\nGeef een lijst met voor elke speler met een boete, het totaal bedrag aan boetes. Als het aantal boetes echter groter is dan 2, zet je ‘veel boetes’. Bij de andere spelers zet je een -. Sorteer op aantal boetes aflopend en daarna op totaal boetebedrag aflopend.\n\n\n\n\nSELECT spelersnr, SUM(bedrag) AS totaalboetebedrag,\nCASE\nWHEN COUNT(bedrag) &gt; 2 THEN ‘veel boetes’\nELSE ‘-’\nEND\nAS status\nFROM boetes\nGROUP BY spelersnr\nORDER BY COUNT(bedrag) DESC, SUM(bedrag) DESC;\n\n\n\n\n\n\nGeef per team, waarvoor wedstrijden gespeeld zijn, het gemiddeld aantal gewonnen en verloren sets. Rond de gemiddelden af tot op twee cijfers na de komma. Sorteer op teamnr.\n\n\n\n\nSELECT w.teamnr,\nROUND(AVG(CAST(w.gewonnen as decimal)),2) as gem_gewonnen,\nROUND(AVG(CAST(w.verloren AS decimal)),2) as gem_verloren\nFROM wedstrijden w\nGROUP BY w.teamnry\nORDER BY w.teamnr\n\n\n\n\n\n\nGeef alle spelers die meer dan één wedstrijd gewonnen hebben.\n\n\n\n\nSELECT spelers.spelersnr, spelers.naam\nFROM wedstrijden, spelers\nWHERE wedstrijden.spelersnr = spelers.spelersnr\nAND wedstrijden.gewonnen &gt; wedstrijden.verloren\nGROUP BY spelers.spelersnr, spelers.naam\nHAVING COUNT(*) &gt; 1\n\n\n\n\n\n\nGeef voor alle actieve bestuursleden die al een boete gehad hebben van meer dan 50 euro hun maximale boetebedrag. Gebruik geen DISTINCT.\n\n\n\n\nSELECT bestuursleden.spelersnr, MAX(boetes.bedrag)\nAS maximum\nFROM boetes, bestuursleden\nWHERE boetes.spelersnr = bestuursleden.spelersnr\nAND bestuursleden.eind_datum IS NULL\nGROUP BY bestuursleden.spelersnr\nHAVING MAX(boetes.bedrag) &gt; 50;\n\n\n\n\n\n\nSorteer de teams in functie van het aantal verloren wedstrijden (oplopend). Als het aantal verloren wedstrijden gelijk is, sorteer je op het totaal aantal gewonnen sets (aflopend) en op divisienaam (oplopend). Een wedstrijd die verloren werd met 3 - 0 telt niet mee in deze output. Geef het aantal wedstrijden dat voldoet aan bovenstaande voorwaarde mee in de output.\n\n\n\n\nSELECT teams.divisie, COUNT(*) AS aantal\nFROM wedstrijden, teams\nWHERE wedstrijden.teamnr = teams.teamnr\nAND wedstrijden.verloren &gt; wedstrijden.gewonnen\nAND NOT (wedstrijden.verloren = 3 AND\nwedstrijden.gewonnen = 0)\nGROUP BY teams.divisie\nORDER BY aantal, SUM(wedstrijden.gewonnen) DESC,\nteams.divisie;\n\n\n\n\n\n\nGeef de teams en het aantal verschillende spelers dat voor dit team gespeeld heeft. Sorteer op divisie.\n\n\n\n\nSELECT teams.divisie, COUNT(DISTINCT wedstrijden.spelersnr) AS aantal\nFROM wedstrijden, teams\nWHERE wedstrijden.teamnr = teams.teamnr\nGROUP BY teams.divisie\nORDER BY teams.divisie;\n\n\n\n\n\n\nGeef de teams (het nummer van het team en de divisie) waarvoor meer dan vier verschillende spelers gespeeld hebben.\n\n\n\n\nSELECT teams.teamnr, teams.divisie\nFROM wedstrijden, teams\nWHERE wedstrijden.teamnr = teams.teamnr\nGROUP BY teams.teamnr, teams.divisie\nHAVING COUNT(DISTINCT wedstrijden.spelersnr) &gt; 4;\n\n\n\n\n\n\nMaak een lijst met per spelersnummer het aantal wedstrijden dat een speler verloren heeft op voorwaarde dat deze speler meer dan één wedstrijd verloren heeft. Bijkomend moet de lijst gesorteerd worden op basis van het spelersnummer.\n\n\n\n\nSELECT spelersnr, COUNT() AS aantal\nFROM wedstrijden\nWHERE gewonnen &lt; verloren\nGROUP BY spelersnr\nHAVING COUNT() &gt; 1\nORDER BY spelersnr;\n\n\n\n\n\n\nGeef een lijst met de spelers die ooit bestuurslid zijn geweest (of nog steeds zijn) en niet in Den Haag of Zoetermeer wonen. Bijkomend mag deze speler maximaal 2 keer in het bestuur van de club gezeteld hebben. De lijst moet aflopend gesorteerd worden op het aantal maal dat de betreffende speler in het bestuur zetelde. Mensen met hetzelfde aantal keren moeten oplopend gesorteerd worden op basis van hun spelersnr.\n\n\n\n\nSELECT spelers.naam, COUNT() AS aantal\nFROM spelers, bestuursleden\nWHERE bestuursleden.spelersnr = spelers.spelersnr\nAND plaats NOT IN (‘Den Haag’, ‘Zoetermeer’)\nGROUP BY spelers.spelersnr, spelers.naam\nHAVING COUNT() &lt;= 2\nORDER BY aantal DESC, spelers.spelersnr;\n\n\n\n\n\n\nGeef het gemiddeld aantal gewonnen en verloren sets per geboortejaar. Sorteer op geboortejaar.\n\n\n\n\nSELECT strftime(‘%Y’, geb_datum) AS geboortejaar, AVG(gewonnen) AS gewonnen, AVG(verloren) AS verloren FROM wedstrijden INNER JOIN spelers ON (wedstrijden.spelersnr = spelers.spelersnr) GROUP BY strftime(‘%Y’, geb_datum) ORDER BY geboortejaar\n\n\n\n\n\nGeef spelers die in het jaar dat ze lid geworden zijn van de club reeds een boete van meer dan 50 euro gekregen hebben en de som van al deze boetes groter of gelijk is aan 100 euro. Geef buiten de voorletters en de naam van de speler ook het aantal boetes die aan bovenstaande voorwaarden voldoen. Sorteer op spelersnr.\n\n\n\n\nSELECT spelers.voorletters, spelers.naam, COUNT(*) AS aantalboetes\nFROM spelers, boetes\nWHERE spelers.spelersnr = boetes.spelersnr\nAND boetes.bedrag &gt; 50 AND strftime(‘%Y’,boetes.datum) = spelers.jaartoe\nGROUP BY spelers.spelersnr, spelers.voorletters, spelers.naam\nHAVING SUM(bedrag) &gt;= 100\nORDER BY spelers.spelersnr;\n\n\n\n\n\n\nGeef het gemiddeld boetebedrag per speler, afgerond op twee cijfers na de komma. Spelers zonder boete krijgen als waarde ‘geen boetes’. Sorteer op spelersnaam.\n\n\n\n\nSELECT spelers.naam,\nCASE\nWHEN AVG(boetes.bedrag) IS NULL THEN ‘geen boetes’\nELSE CAST(ROUND(AVG(boetes.bedrag), 2) AS varchar(8))\nEND AS gemiddeld\nFROM spelers LEFT OUTER JOIN boetes ON spelers.spelersnr = boetes.spelersnr\nGROUP BY spelers.spelersnr, spelers.naam\nORDER BY 1\n\n\n\n\n\n\nGeef het gemiddeld aantal gewonnen en verloren sets per geboortejaar. Rond telkens af op twee cijfers na de komma. Sorteer op geboortejaar zodat de gegevens van de jongste spelers bovenaan staan.\n\n\n\n\nSELECT strftime(‘%Y’, geb_datum) AS geboortejaar, ROUND(AVG(gewonnen),2) AS gewonnen,\nROUND(AVG(verloren),2) AS verloren\nFROM wedstrijden W INNER JOIN spelers S ON W.spelersnr = S.spelersnr\nGROUP BY strftime(‘%Y’,geb_datum)\nORDER BY geboortejaar DESC;\n\n\n\n\n\n\nGeef voor de actieve bestuursleden zonder boete hun laatste gespeelde wedstrijd (die met het hoogste wedstrijdnummer). Sorteer aflopend op spelersnr.\n\n\n\n\nSELECT bestuursleden.spelersnr, MAX(wedstrijden.wedstrijdnr) AS laatste_wedstrijd\nFROM bestuursleden\nINNER JOIN wedstrijden ON bestuursleden.spelersnr = wedstrijden.spelersnr AND\nbestuursleden.eind_datum IS NULL\nLEFT OUTER JOIN boetes ON bestuursleden.spelersnr = boetes.spelersnr\nWHERE boetes.spelersnr IS NULL\nGROUP BY bestuursleden.spelersnr\nORDER BY bestuursleden.spelersnr DESC;\n\n\n\n\n\n\nGeef het hoogste wedstrijdnummer voor de teams waarvoor wedstrijden gespeeld zijn door bestuursleden (actief en niet meer actief) die geen boete hebben gekregen. Sorteer op teamnr.\n\n\n\n\nSELECT teams.teamnr, MAX(wedstrijden.wedstrijdnr) AS laatstewedstrijd FROM teams INNER JOIN wedstrijden on teams.teamnr = wedstrijden.teamnr INNER JOIN bestuursleden ON wedstrijden.spelersnr = bestuursleden.spelersnr LEFT OUTER JOIN boetes ON bestuursleden.spelersnr = boetes.spelersnr WHERE boetes.spelersnr IS NULL GROUP BY teams.teamnr ORDER BY teams.teamnr;\n\n\n\n\n\nGeef alle spelers (nummer) die meer wedstrijden gespeeld hebben dan het aantal wedstrijden dat de huidige voorzitter heeft verloren. De huidige voorzitter komt zelf niet in de lijst voor. Gebruik geen subqueries. Sorteer op spelersnr.\n\n\n\n\nSELECT spelers.spelersnr FROM spelers INNER JOIN wedstrijden ON spelers.spelersnr = wedstrijden.spelersnr, bestuursleden INNER JOIN wedstrijden voorzitterswedstrijden ON bestuursleden.spelersnr = voorzitterswedstrijden.spelersnr AND voorzitterswedstrijden.gewonnen &lt; voorzitterswedstrijden.verloren WHERE bestuursleden.eind_datum IS NULL AND bestuursleden.functie = ‘Voorzitter’ AND bestuursleden.spelersnr &lt;&gt; spelers.spelersnr GROUP BY spelers.spelersnr HAVING COUNT(DISTINCT wedstrijden.wedstrijdnr) &gt; COUNT(DISTINCT voorzitterswedstrijden.wedstrijdnr) ORDER BY spelers.spelersnr;"
  },
  {
    "objectID": "sql_course/11_exercises_subqueries.html#de-tennisvereniging",
    "href": "sql_course/11_exercises_subqueries.html#de-tennisvereniging",
    "title": "Oefeningen subqueries",
    "section": "",
    "text": "Algemene info over dit database schema kan je hier vinden.\n\n\n\nWatterson, Calvin and Hobbes"
  },
  {
    "objectID": "sql_course/11_exercises_subqueries.html#subqueries-h5",
    "href": "sql_course/11_exercises_subqueries.html#subqueries-h5",
    "title": "Oefeningen subqueries",
    "section": "SUBQUERIES (H5)",
    "text": "SUBQUERIES (H5)\n\n\nOefening 1\nGeef van elke speler waarvan het nummer kleiner is dan 60 het aantal jaren dat ligt tussen het jaar van toetreding van die speler en dan van speler 100.\n\n\n\n\nSELECT spelersnr, jaartoe -\n(SELECT jaartoe\nfrom spelers\nwhere spelersnr = 100)\nFROM spelers\nwhere spelersnr &lt; 60\n\n\n\n\n\nOefening 2\nGeef de nummers van de spelers die in hetzelfde jaar geboren zijn als speler 27\n\n\n\n\nSELECT spelersnr\nFROM spelers\nWHERE YEAR(geb_datum) =\n(select YEAR(geb_datum)\nfrom spelers\nwhere spelersnr = 27)\n\n\n\n\n\nOefening 3\nDOORDENKER: Geef de nummers van de spelers die hetzelfde geslacht hebben en in dezelfde plaats wonen als speler 100.\n\n\n\n\nSELECT spelersnr\nfrom spelers\nwhere (geslacht, plaats) = (select geslacht, plaats\nfrom spelers\nwhere spelersnr = 100)\n\n\n\n\n\nOefening 4\nGeef de nummers van de teams waarvan de speler met naam Permentier en voorletter R aanvoerder is; we gaan er in deze opgave van uit dat er geen twee spelers zijn met dezelfde naam en voorletters.\n\n\n\n\nSELECT teamnr\nFROM teams\nWHERE spelersnr =\n(select spelersnr\nfrom spelers\nwhere naam = ‘Permentier’\nand voorletters = ‘R’)\n\n\n\n\n\nOefening 5\nDOORDOORDENKER: Geef de naam van de speler die aanvoerder is van het team waartoe wedstrijd 6 behoort.\n\n\n\n\nSELECT naam\nFROM spelers\nWHERE spelersnr =\n(select spelersnr\nfrom teams\nwhere teamnr =\n(select teamnr\nfrom wedstrijden\nwhere wedstrijdnr = 6))\n\n\n\n\n\nOefening 6\nGeef de nummers van de boetes die hoger zijn dan de boete met betalingsnr 4\n\n\n\n\nSELECT betalingsnr FROM boetes WHERE bedrag &gt; (SELECT bedrag FROM boetes WHERE betalingsnr = 4)\n\n\n\n\nOefening 7\nGeef de nummers van de spelers die op dezelfde weekdag zijn geboren als speler 2\n\n\n\n\nSELECT spelersnr FROM spelers WHERE DAYNAME(geb_datum) = (select DAYNAME(geb_datum) FROM SPELERS WHERE spelersnr = 2)\n\n\n\n\nOefening 8\nDOORDENKER:Geef de nummers van de bestuursleden die een functie zijn begonnen en diezelfde functie weer hebben neergelegd op dezelfde datums als waarop speler 8 de functie van penningmeester heeft geaccepteerd en weer heeft neergelegd. Speler 8 mag zelf niet in het eindresultaat voorkomen.\n\n\n\n\nSELECT spelersnr FROM bestuursleden WHERE (begin_datum,eind_datum) = (select begin_datum,eind_datum from bestuursleden where spelersnr = 8 and functie = ‘Penningmeester’) AND spelersnr &lt;&gt; 8\n\n\n\n\nOefening 9\nGeef de divisies van teams 1 en 2 en plaats deze naast elkaar in het resultaat\n\n\n\n\nSELECT (select divisie from teams where teamnr = 1),(select divisie from teams where teamnr = 2)\n\n\n\n\nOefening 10\nGeef de nummers van de wedstrijden gespeeld door spelers die in Rijswijk wonen. Probeer met een subquery\n\n\n\n\nselect wedstrijdnr from wedstrijden w inner join spelers s on w.spelersnr=s.spelersnr where s.plaats = ‘Rijswijk’\nOF\nselect wedstrijdnr\nfrom wedstrijden\nwhere ‘Rijswijk’ =\n(select plaats\nfrom spelers\nwhere spelers.spelersnr = wedstrijden.spelersnr)\n\n\n\n\n\nOefening 11\nGeef de wedstrijdnummers, spelersnummers en de teamnummers van alle wedstrijden gespeeld door een speler die tevens de aanvoerder van dat team is. Probeer met een subquery\n\n\n\n\n–SELECT wedstrijdnr,spelersnr,teamnr –FROM wedstrijden w –WHERE spelersnr IN (select spelersnr from teams WHERE wedstrijden.teamnr = teams.teamnr )\nSELECT w.wedstrijdnr, t.spelersnr AS t_spelersnr, w.spelersnr AS w_spelersnr, t.teamnr AS t_teamnr, w.teamnr AS w_teamnr FROM wedstrijden w INNER JOIN teams t ON(w.spelersnr = t.spelersnr AND w.teamnr = t.teamnr)\n\n\n\n\nOefening 12\nGeef de nummers en de naam van de aanvoerders voor wie minstens twee boetes zijn betaald.\n\n\n\n\n–SELECT s.spelersnr, s.naam –FROM spelers s INNER JOIN teams t ON (s.spelersnr = t.spelersnr) –WHERE s.spelersnr IN –(SELECT b.spelersnr –FROM boetes b –GROUP BY b.spelersnr –HAVING count(betalingsnr)&gt;=2);\nSELECT s.spelersnr, s.naam, COUNT(betalingsnr) AS aantal_boetes FROM spelers s INNER JOIN boetes b ON (s.spelersnr = b.spelersnr) INNER JOIN teams t ON (s.spelersnr = t.spelersnr) GROUP BY s.spelersnr HAVING COUNT(betalingsnr)&gt;=2\n\n\n\n\nOefening 13\nTENNIS: Zelf een oefening verzinnen en opdracht geven naar collega’s\n\n\n\n\n\n\n\n\n\nOefening 14\nHR: Zelf een oefening verzinnen en opdracht geven naar collega’s"
  },
  {
    "objectID": "sql_course/12_exercise_DDL.html#de-fietsenwinkel",
    "href": "sql_course/12_exercise_DDL.html#de-fietsenwinkel",
    "title": "Oefeningen DDL - Fietsenwinkel",
    "section": "",
    "text": "Algemene info over dit database schema kan je hier vinden.\n\n\n\nFietsenwinkel"
  },
  {
    "objectID": "sql_course/12_exercise_DDL.html#ddl",
    "href": "sql_course/12_exercise_DDL.html#ddl",
    "title": "Oefeningen DDL - Fietsenwinkel",
    "section": "DDL",
    "text": "DDL\n\n\nOefening 1\nDe database is reeds gecreëerd volgens de aangegeven schema’s in de figuur. Maak jezelf klant in de database (INSERT statement) door een fiets te kopen (althans door dit in de databank toe te voegen).\n\n\n\n\n\n\nOefening 2\nWhich state has the most customers?\n\nSELECT state, COUNT (customer_id) as nb_customer FROM customers GROUP BY state ORDER BY nb_customer DESC\n\n\n\n\nOefening 3\nWhich brand has the most products in the store?\n\nSELECT COUNT(products.product_id) as product_per_brand, brands.brand_name FROM production.brands\nJOIN production.products ON products.brand_id = brands.brand_id\nGROUP BY brands.brand_id, brands.brand_name ORDER BY product_per_brand DESC\n\n\n\n\n\nOefening 4\nWhich product is the most ordered? Give me product_id, quantity and product_name\n\nSELECT TOP 10 b.product_id, SUM(a.quantity) as quantity, b.product_name FROM sales.order_items a\nJOIN production.products b ON a.product_id = b.product_id\nGROUP BY b.product_id, b.product_name ORDER BY quantity DESC\n\nTotalQuantityOrdered = SUM(order_items[quantity])\n\n\n\n\n\nOefening 5\nWhich product is sold out in each store?\n\nSELECT stores.store_name, stocks.product_id, products.product_name FROM production.stocks\nJOIN production.products ON stocks.product_id = products.product_id\nJOIN sales.stores ON stocks.store_id = stores.store_id\nWHERE quantity = 0\n\n\n\n\n\nOefening 6\nWhich product is the most ordered?\n\nWITH price AS (\nSELECT product_id, quantity, list_price, discount, list_price * quantity * (1 - discount) AS final\nFROM sales.order_items\n)\nSELECT a.product_id, a.product_name, SUM(b.final) AS sales_revenue\nFROM price b\nJOIN production.products a\nON a.product_id = b.product_id\nGROUP BY a.product_id, a.product_name\nORDER BY sales_revenue DESC;\n\n\n\n\n\nOefening 7\nCalculate the average bike price for each model year\n\nSELECT model_year, AVG(list_price) AS avg_price FROM production.products GROUP BY model_year\n\n\n\n\nOefening 8\nHow many staffs are active in all stores?\n\n\n\n\n\n\nOefening 9\nWhich store has the most late-shipped orders?\n\nselect s.store_name, count(*) as aantal_late_shipped_orders\nfrom sales.orders o join sales.stores s on o.store_id = s.store_id\nwhere o.shipped_date &gt; o.required_date\ngroup by s.store_name\norder by aantal_late_shipped_orders desc;\n\nWITH status AS (SELECT order_id, required_date, shipped_date,\nCASE\nWHEN required_date &lt;= shipped_date THEN 0\nELSE 1\nEND AS late_shipping, store_id\nFROM orders\nWHERE shipped_date IS NOT NULL AND late_shipping = 1)\nSELECT store_id, COUNT(late_shipping) as nb_late_shipping\nFROM status GROUP BY store_id\n\n\n\n\nOefening 10\nWhich product is the most ordered?\n\nSELECT\nYEAR(o.order_date) AS order_year,\nFORMAT(o.order_date, ‘MM’) AS order_month,\np.category_id,\nc.category_name,\nAVG(oi.quantity * oi.list_price * (1 - oi.discount)) AS avg_monthly_sales\nFROM\nsales.order_items oi\nJOIN\nproduction.products p ON oi.product_id = p.product_id\nJOIN\nsales.orders o ON oi.order_id = o.order_id\nJOIN\nproduction.categories c ON c.category_id = p.category_id\nGROUP BY\nYEAR(o.order_date) AS order_year,\nFORMAT(o.order_date, ‘MM’),\np.category_id,\nc.category_name\nORDER BY order_year,order_month;\n\n\n\n\n\nOefening 11\nPercentage of late shipments per store. Give store_id, total_late, total, percentage_late.\n\nWITH late AS(SELECT store_id,\nCASE\nWHEN required_date &lt;= shipped_date THEN 0\nELSE 1\nEND AS late_shipping FROM sales.orders WHERE shipped_date IS NOT NULL)\nSELECT store_id, SUM(late_shipping) AS late, COUNT(late_shipping) AS total, CAST(100*SUM(late_shipping)/COUNT(late_shipping) AS FLOAT) AS percent_late_shipping\nFROM late GROUP BY store_id"
  },
  {
    "objectID": "sql_course/Bikestore_uitleg.html",
    "href": "sql_course/Bikestore_uitleg.html",
    "title": "De Bikestore",
    "section": "",
    "text": "Database schema\n\n\n\nBelangrijke informatie bij de bike store database\nZoals je in het diagram kunt zien, heeft de BikeStores voorbeeld database twee schema’s: verkoop en productie, en deze schema’s hebben negen tabellen. De tabel sales.stores bevat de winkelinformatie. Elke winkel heeft een winkelnaam, contactinformatie zoals telefoon en e-mail, en een adres inclusief straat, stad, staat en postcode. In de tabel sales.staffs wordt de essentiële informatie van het personeel opgeslagen, waaronder de voornaam en achternaam. Het bevat ook de communicatie-informatie zoals e-mail en telefoon.\nEen medewerker werkt in een winkel die wordt gespecificeerd door de waarde in de store_id kolom. Een winkel kan een of meer medewerkers hebben.\nEen medewerker rapporteert aan een filiaalmanager die gespecificeerd wordt door de waarde in de manager_id kolom. Als de waarde in de manager_id nul is, dan is het personeel de topmanager.\nAls een medewerker niet langer voor een winkel werkt, wordt de waarde in de kolom actief op nul gezet.\nDe tabel production.categories slaat de fietscategorieën op, zoals kinderfietsen, comfortfietsen en elektrische fietsen. De tabel production.brands slaat de merkinformatie van fietsen op, bijvoorbeeld Electra, Haro en Heller. De tabel production.products slaat productinformatie op, zoals naam, merk, categorie, modeljaar en catalogusprijs.\nElk product behoort tot een merk dat wordt gespecificeerd door de kolom brand_id. Een merk kan dus nul of veel producten hebben.\nElk product behoort ook tot een categorie die wordt gespecificeerd door de categorie_id kolom. Elke categorie kan ook nul of veel producten hebben. De tabel sales.customers slaat klantgegevens op, waaronder voornaam, achternaam, telefoon, e-mail, straat, stad, staat en postcode. In de tabel sales.orders worden de hoofdgegevens van de verkooporder opgeslagen, waaronder de klant, de status van de order, de besteldatum, de vereiste datum en de verzenddatum.\nDe tabel slaat ook de informatie op over waar de verkooptransactie is aangemaakt (winkel) en wie deze heeft aangemaakt (personeel). In de tabel sales.order_items worden de regelitems van een verkooporder opgeslagen. Elk regelitem hoort bij een verkooporder die wordt gespecificeerd door de order_id kolom.\nEen regelitem van een verkooporder bevat het product, de bestelhoeveelheid, de catalogusprijs en de korting.\nElke verkooporder heeft een rij in de tabel verkooporders. Een verkooporder heeft een of meer regelitems die zijn opgeslagen in de tabel sales.order_items.\nDe tabel production.stocks slaat de voorraadinformatie op, d.w.z. de hoeveelheid van een bepaald product in een specifieke winkel."
  },
  {
    "objectID": "sql_course/11_exercises_subqueries.html",
    "href": "sql_course/11_exercises_subqueries.html",
    "title": "Oefeningen subqueries",
    "section": "",
    "text": "Algemene info over dit database schema kan je hier vinden.\n\n\n\nWatterson, Calvin and Hobbes"
  },
  {
    "objectID": "posts_main.html",
    "href": "posts_main.html",
    "title": "My Blog",
    "section": "",
    "text": "My first blog\n\n\n\nQuarto\n\nR\n\nData Science\n\n\n\nblog post description (appears underneath the title in smaller text) which is included on the listing page\n\n\n\nDanny Volkaerts\n\n\nJun 5, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts_main/2024_05_18_My_first_blog/index.html",
    "href": "posts_main/2024_05_18_My_first_blog/index.html",
    "title": "My first blog",
    "section": "",
    "text": "CitationBibTeX citation:@online{volkaerts2025,\n  author = {Volkaerts, Danny},\n  title = {My First Blog},\n  date = {2025-06-05},\n  url = {https://dannyvolkaerts.github.io/posts/2022-10-24-my-blog-post/},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nVolkaerts, Danny. 2025. “My First Blog.” June 5, 2025. https://dannyvolkaerts.github.io/posts/2022-10-24-my-blog-post/."
  },
  {
    "objectID": "sql_course/12_exercise_DDL.html",
    "href": "sql_course/12_exercise_DDL.html",
    "title": "Oefeningen DDL - Fietsenwinkel",
    "section": "",
    "text": "Algemene info over dit database schema kan je hier vinden.\n\n\n\nFietsenwinkel"
  },
  {
    "objectID": "sql_course/10_exercises_advanced.html",
    "href": "sql_course/10_exercises_advanced.html",
    "title": "Oefeningen advanced",
    "section": "",
    "text": "Algemene info over dit database schema kan je hier vinden.\n\n\n\nWatterson, Calvin and Hobbes\n\n\n\n\n\n\nMaak een overzicht waarbij je per woonplaats aangeeft hoeveel spelers er wonen in die gemeente.Sorteer op plaats.\n\n\n\n\nSELECT plaats, COUNT(*) AS aantal\nFROM spelers\nGROUP BY plaats\nORDER BY plaats;\n\n\n\n\n\n\nGa na hoeveel mannelijke en hoeveel vrouwelijke spelers de club telt. Zorg ervoor dat je lijst gesorteerd wordt van het grootst aantal spelers naar het kleinste aantal.\n\n\n\n\nSELECT geslacht, COUNT(*) AS aantal\nFROM spelers\nGROUP BY geslacht\nORDER BY aantal DESC;\n\n\n\n\n\n\nGeef een lijst met het totaalbedrag aan boetes per speler. Sorteer het hoogste totale boetebedrag bovenaan.\n\n\n\n\nSELECT spelersnr, SUM(bedrag) AS totaalboetebedrag\nFROM boetes\nGROUP BY spelersnr\nORDER BY totaalboetebedrag DESC;\n\n\n\n\n\n\nGeef een lijst met voor elke speler met een boete, het totaal bedrag aan boetes. Als het aantal boetes echter groter is dan 2, zet je ‘veel boetes’. Bij de andere spelers zet je een -. Sorteer op aantal boetes aflopend en daarna op totaal boetebedrag aflopend.\n\n\n\n\nSELECT spelersnr, SUM(bedrag) AS totaalboetebedrag,\nCASE\nWHEN COUNT(bedrag) &gt; 2 THEN ‘veel boetes’\nELSE ‘-’\nEND\nAS status\nFROM boetes\nGROUP BY spelersnr\nORDER BY COUNT(bedrag) DESC, SUM(bedrag) DESC;\n\n\n\n\n\n\nGeef per team, waarvoor wedstrijden gespeeld zijn, het gemiddeld aantal gewonnen en verloren sets. Rond de gemiddelden af tot op twee cijfers na de komma. Sorteer op teamnr.\n\n\n\n\nSELECT w.teamnr,\nROUND(AVG(CAST(w.gewonnen as decimal)),2) as gem_gewonnen,\nROUND(AVG(CAST(w.verloren AS decimal)),2) as gem_verloren\nFROM wedstrijden w\nGROUP BY w.teamnry\nORDER BY w.teamnr\n\n\n\n\n\n\nGeef alle spelers die meer dan één wedstrijd gewonnen hebben.\n\n\n\n\nSELECT spelers.spelersnr, spelers.naam\nFROM wedstrijden, spelers\nWHERE wedstrijden.spelersnr = spelers.spelersnr\nAND wedstrijden.gewonnen &gt; wedstrijden.verloren\nGROUP BY spelers.spelersnr, spelers.naam\nHAVING COUNT(*) &gt; 1\n\n\n\n\n\n\nGeef voor alle actieve bestuursleden die al een boete gehad hebben van meer dan 50 euro hun maximale boetebedrag. Gebruik geen DISTINCT.\n\n\n\n\nSELECT bestuursleden.spelersnr, MAX(boetes.bedrag)\nAS maximum\nFROM boetes, bestuursleden\nWHERE boetes.spelersnr = bestuursleden.spelersnr\nAND bestuursleden.eind_datum IS NULL\nGROUP BY bestuursleden.spelersnr\nHAVING MAX(boetes.bedrag) &gt; 50;\n\n\n\n\n\n\nSorteer de teams in functie van het aantal verloren wedstrijden (oplopend). Als het aantal verloren wedstrijden gelijk is, sorteer je op het totaal aantal gewonnen sets (aflopend) en op divisienaam (oplopend). Een wedstrijd die verloren werd met 3 - 0 telt niet mee in deze output. Geef het aantal wedstrijden dat voldoet aan bovenstaande voorwaarde mee in de output.\n\n\n\n\nSELECT teams.divisie, COUNT(*) AS aantal\nFROM wedstrijden, teams\nWHERE wedstrijden.teamnr = teams.teamnr\nAND wedstrijden.verloren &gt; wedstrijden.gewonnen\nAND NOT (wedstrijden.verloren = 3 AND\nwedstrijden.gewonnen = 0)\nGROUP BY teams.divisie\nORDER BY aantal, SUM(wedstrijden.gewonnen) DESC,\nteams.divisie;\n\n\n\n\n\n\nGeef de teams en het aantal verschillende spelers dat voor dit team gespeeld heeft. Sorteer op divisie.\n\n\n\n\nSELECT teams.divisie, COUNT(DISTINCT wedstrijden.spelersnr) AS aantal\nFROM wedstrijden, teams\nWHERE wedstrijden.teamnr = teams.teamnr\nGROUP BY teams.divisie\nORDER BY teams.divisie;\n\n\n\n\n\n\nGeef de teams (het nummer van het team en de divisie) waarvoor meer dan vier verschillende spelers gespeeld hebben.\n\n\n\n\nSELECT teams.teamnr, teams.divisie\nFROM wedstrijden, teams\nWHERE wedstrijden.teamnr = teams.teamnr\nGROUP BY teams.teamnr, teams.divisie\nHAVING COUNT(DISTINCT wedstrijden.spelersnr) &gt; 4;\n\n\n\n\n\n\nMaak een lijst met per spelersnummer het aantal wedstrijden dat een speler verloren heeft op voorwaarde dat deze speler meer dan één wedstrijd verloren heeft. Bijkomend moet de lijst gesorteerd worden op basis van het spelersnummer.\n\n\n\n\nSELECT spelersnr, COUNT() AS aantal\nFROM wedstrijden\nWHERE gewonnen &lt; verloren\nGROUP BY spelersnr\nHAVING COUNT() &gt; 1\nORDER BY spelersnr;\n\n\n\n\n\n\nGeef een lijst met de spelers die ooit bestuurslid zijn geweest (of nog steeds zijn) en niet in Den Haag of Zoetermeer wonen. Bijkomend mag deze speler maximaal 2 keer in het bestuur van de club gezeteld hebben. De lijst moet aflopend gesorteerd worden op het aantal maal dat de betreffende speler in het bestuur zetelde. Mensen met hetzelfde aantal keren moeten oplopend gesorteerd worden op basis van hun spelersnr.\n\n\n\n\nSELECT spelers.naam, COUNT() AS aantal\nFROM spelers, bestuursleden\nWHERE bestuursleden.spelersnr = spelers.spelersnr\nAND plaats NOT IN (‘Den Haag’, ‘Zoetermeer’)\nGROUP BY spelers.spelersnr, spelers.naam\nHAVING COUNT() &lt;= 2\nORDER BY aantal DESC, spelers.spelersnr;\n\n\n\n\n\n\nGeef het gemiddeld aantal gewonnen en verloren sets per geboortejaar. Sorteer op geboortejaar.\n\n\n\n\nSELECT strftime(‘%Y’, geb_datum) AS geboortejaar, AVG(gewonnen) AS gewonnen, AVG(verloren) AS verloren FROM wedstrijden INNER JOIN spelers ON (wedstrijden.spelersnr = spelers.spelersnr) GROUP BY strftime(‘%Y’, geb_datum) ORDER BY geboortejaar\n\n\n\n\n\nGeef spelers die in het jaar dat ze lid geworden zijn van de club reeds een boete van meer dan 50 euro gekregen hebben en de som van al deze boetes groter of gelijk is aan 100 euro. Geef buiten de voorletters en de naam van de speler ook het aantal boetes die aan bovenstaande voorwaarden voldoen. Sorteer op spelersnr.\n\n\n\n\nSELECT spelers.voorletters, spelers.naam, COUNT(*) AS aantalboetes\nFROM spelers, boetes\nWHERE spelers.spelersnr = boetes.spelersnr\nAND boetes.bedrag &gt; 50 AND strftime(‘%Y’,boetes.datum) = spelers.jaartoe\nGROUP BY spelers.spelersnr, spelers.voorletters, spelers.naam\nHAVING SUM(bedrag) &gt;= 100\nORDER BY spelers.spelersnr;\n\n\n\n\n\n\nGeef het gemiddeld boetebedrag per speler, afgerond op twee cijfers na de komma. Spelers zonder boete krijgen als waarde ‘geen boetes’. Sorteer op spelersnaam.\n\n\n\n\nSELECT spelers.naam,\nCASE\nWHEN AVG(boetes.bedrag) IS NULL THEN ‘geen boetes’\nELSE CAST(ROUND(AVG(boetes.bedrag), 2) AS varchar(8))\nEND AS gemiddeld\nFROM spelers LEFT OUTER JOIN boetes ON spelers.spelersnr = boetes.spelersnr\nGROUP BY spelers.spelersnr, spelers.naam\nORDER BY 1\n\n\n\n\n\n\nGeef het gemiddeld aantal gewonnen en verloren sets per geboortejaar. Rond telkens af op twee cijfers na de komma. Sorteer op geboortejaar zodat de gegevens van de jongste spelers bovenaan staan.\n\n\n\n\nSELECT strftime(‘%Y’, geb_datum) AS geboortejaar, ROUND(AVG(gewonnen),2) AS gewonnen,\nROUND(AVG(verloren),2) AS verloren\nFROM wedstrijden W INNER JOIN spelers S ON W.spelersnr = S.spelersnr\nGROUP BY strftime(‘%Y’,geb_datum)\nORDER BY geboortejaar DESC;\n\n\n\n\n\n\nGeef voor de actieve bestuursleden zonder boete hun laatste gespeelde wedstrijd (die met het hoogste wedstrijdnummer). Sorteer aflopend op spelersnr.\n\n\n\n\nSELECT bestuursleden.spelersnr, MAX(wedstrijden.wedstrijdnr) AS laatste_wedstrijd\nFROM bestuursleden\nINNER JOIN wedstrijden ON bestuursleden.spelersnr = wedstrijden.spelersnr AND\nbestuursleden.eind_datum IS NULL\nLEFT OUTER JOIN boetes ON bestuursleden.spelersnr = boetes.spelersnr\nWHERE boetes.spelersnr IS NULL\nGROUP BY bestuursleden.spelersnr\nORDER BY bestuursleden.spelersnr DESC;\n\n\n\n\n\n\nGeef het hoogste wedstrijdnummer voor de teams waarvoor wedstrijden gespeeld zijn door bestuursleden (actief en niet meer actief) die geen boete hebben gekregen. Sorteer op teamnr.\n\n\n\n\nSELECT teams.teamnr, MAX(wedstrijden.wedstrijdnr) AS laatstewedstrijd FROM teams INNER JOIN wedstrijden on teams.teamnr = wedstrijden.teamnr INNER JOIN bestuursleden ON wedstrijden.spelersnr = bestuursleden.spelersnr LEFT OUTER JOIN boetes ON bestuursleden.spelersnr = boetes.spelersnr WHERE boetes.spelersnr IS NULL GROUP BY teams.teamnr ORDER BY teams.teamnr;\n\n\n\n\n\nGeef alle spelers (nummer) die meer wedstrijden gespeeld hebben dan het aantal wedstrijden dat de huidige voorzitter heeft verloren. De huidige voorzitter komt zelf niet in de lijst voor. Gebruik geen subqueries. Sorteer op spelersnr.\n\n\n\n\nSELECT spelers.spelersnr FROM spelers INNER JOIN wedstrijden ON spelers.spelersnr = wedstrijden.spelersnr, bestuursleden INNER JOIN wedstrijden voorzitterswedstrijden ON bestuursleden.spelersnr = voorzitterswedstrijden.spelersnr AND voorzitterswedstrijden.gewonnen &lt; voorzitterswedstrijden.verloren WHERE bestuursleden.eind_datum IS NULL AND bestuursleden.functie = ‘Voorzitter’ AND bestuursleden.spelersnr &lt;&gt; spelers.spelersnr GROUP BY spelers.spelersnr HAVING COUNT(DISTINCT wedstrijden.wedstrijdnr) &gt; COUNT(DISTINCT voorzitterswedstrijden.wedstrijdnr) ORDER BY spelers.spelersnr;"
  },
  {
    "objectID": "sql_course/7_powerbi.html",
    "href": "sql_course/7_powerbi.html",
    "title": "Integratie van SQL in PowerBI",
    "section": "",
    "text": "PowerBI en SQL vormen een krachtige combinatie voor data-analyse en business intelligence.\nPowerBI stelt gebruikers in staat om data vanuit SQL visueel te verkennen en interactieve rapporten te creëren.\n\n\n\n\n\nSamen stellen ze organisaties in staat om:\n\nDiepgaande Inzichten te Verkrijgen: Gebruik SQL voor complexe dataverwerking en -analyse voordat je deze visualiseert in PowerBI.\nSnellere Besluitvorming: Door realtime toegang tot bijgewerkte data-analyses en rapportages.\nVerbeterde Data Governance: SQL helpt bij het structureren van data terwijl PowerBI zorgt voor de compliance en veiligheid bij het delen van rapporten."
  },
  {
    "objectID": "sql_course/6_DDL.html",
    "href": "sql_course/6_DDL.html",
    "title": "DDL & DML",
    "section": "",
    "text": "DDL\nData Definition Language\nCREATE TABLE table_name(\n     column_name_1 data_type default value column_constraint,\n     column_name_2 data_type default value column_constraint,\n     ...,\n     table_constraint\n);\n\n\n\nCREATE example\n\n\nCREATE TABLE courses (\n    course_id INTEGER PRIMARY KEY,\n    course_name VARCHAR(50) NOT NULL\n);\n\n\n\n\nCREATE example 2\n\n\nCREATE TABLE trainings (\n    training_id INT,\n    course_id INT,\n    taken_date DATE,\n    PRIMARY KEY (training_id),\n    FOREIGN KEY (course_id) REFERENCES courses (course_id) ON DELETE CASCADE\n);\n\n\n\n\nCreate - data types\nDownload PDF file.\n\n\n\nCreate - data types\nDownload PDF file.\n\n\n\nIdentity\nSQL identiteitskolom is een kolom waarvan de waarden automatisch worden gegenereerd wanneer je een nieuwe rij toevoegt aan de tabel.\nSQL server:\n\nCREATE TABLE leave_requests (\n    request_id INT IDENTITY(1,1),\n    employee_id INT NOT NULL,\n    start_date DATE NOT NULL,\n    end_date DATE NOT NULL,\n    leave_type INT NOT NULL,\n    PRIMARY KEY(request_id)\n);\n\n\n\nPrimaire sleutel\nEen tabel bestaat uit kolommen en rijen. Typisch heeft een tabel een kolom of een set kolommen waarvan de waarden elke rij in de tabel op een unieke manier identificeren. Deze kolom of verzameling kolommen wordt de primaire sleutel genoemd.\nDe primaire sleutel die bestaat uit twee of meer kolommen wordt ook wel de samengestelde primaire sleutel genoemd.\nElke tabel heeft één en slechts één primaire sleutel. De primaire sleutel accepteert geen NULL of dubbele waarden.\n\n\n\n\nOther constraints\n\nUnique\nForeign key\n\nDownload PDF file.\n\nUNIQUE constraint: Sometimes, you want to make sure that the values in a column or a set of columns are not duplicate. For example, duplicate emails in the employees table are not acceptable.\n\n\n\n\nINSERT data\nRemember:\nCREATE TABLE courses (\n    course_id INTEGER PRIMARY KEY,\n    course_name VARCHAR(50) NOT NULL\n);\nInsert:\n\nINSERT INTO courses VALUES\n(null,'SQL basics');\n\n\nINSERT INTO courses (course_name) VALUES (‘SQL advanced’) INSERT INTO trainings VALUES (1,1,‘2024-05-01’); DELETE FROM courses WHERE course_id = 1;\n\n\n\n\nAanpassingen - DML\n\naan data: UPDATE\n\naan tabel: EXEC\n\naan kolom: ALTER\n\n\nDownload PDF file.\n\nUPDATE courses\nSET course_name = ‘SQL’\nWHERE course_id &gt; 0\n\n\n\n\n\ntabel verwijderen\n\nDROP TABLE courses\n\n\nthen try to select it\n\n\n\n\nOefeningen\nMaak enkele tabellen aan (database: ‘DV_second_group’)\n\nCountries - Datacamp -&gt; Zie downloads ‘Countries’\nGRANT CREATE TABLE TO student;\nGO\nVoorbeeld zien van de tennis database: eerst DROP SPELERS -&gt; werkt niet owv de cascade!"
  },
  {
    "objectID": "sql_course/8_exercises.html",
    "href": "sql_course/8_exercises.html",
    "title": "Oefeningen hoofdstuk 1 en 2: tennis",
    "section": "",
    "text": "Algemene info over dit database schema kan je hier vinden.\n\n\n\nWatterson, Calvin and Hobbes"
  },
  {
    "objectID": "sql_course/9_exercises_joins.html",
    "href": "sql_course/9_exercises_joins.html",
    "title": "Oefeningen hoofdstuk 3: tennis joins",
    "section": "",
    "text": "Algemene info over dit database schema kan je hier vinden.\n\n\n\nWatterson, Calvin and Hobbes"
  }
]