[
  {
    "objectID": "SQL.html#hr-sample-data",
    "href": "SQL.html#hr-sample-data",
    "title": "Interactive-sql",
    "section": "HR sample data",
    "text": "HR sample data\nHere we will use a sample Database called HR that manages the HR data of the small businesses which is collected from www.sqltutorial.org. And to create the database, a SQLite script file was used when rendering the document. Read the extension docs for details."
  },
  {
    "objectID": "SQL.html#erd-of-hr-database",
    "href": "SQL.html#erd-of-hr-database",
    "title": "Interactive-sql",
    "section": "ERD of HR database",
    "text": "ERD of HR database\nThe following database diagram illustrates the HR sample database:\n\nFigure 1: ERD of HR database"
  },
  {
    "objectID": "SQL.html#editable-example",
    "href": "SQL.html#editable-example",
    "title": "Interactive-sql",
    "section": "Editable Example",
    "text": "Editable Example\nAnd now, you can run all sort of queries from the tables of the HR databases.\n\nselect * from regions;"
  },
  {
    "objectID": "SQL.html#not-editable-example",
    "href": "SQL.html#not-editable-example",
    "title": "Interactive-sql",
    "section": "Not editable example",
    "text": "Not editable example\nYou can also create “not-editable” code chunk (that is, you simply can run the query but won’t be able to edit/modify it) for HR database. And to do this, just use another instance of database under the database key in the yaml with a different name and use the option editable: false."
  },
  {
    "objectID": "SQL.html#not-editable-example-1",
    "href": "SQL.html#not-editable-example-1",
    "title": "Interactive-sql",
    "section": "Not editable example",
    "text": "Not editable example\n\nselect * from employees;"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Danny Volkaerts",
    "section": "",
    "text": "Hi! Welcome to my digital space! As a data enthousiast I’m fueled by curiosity and motivated by the goal of turning data into actionable insights. Whether it’s through Machine Learning, data analysis, or data visualizations, I explore data in all its forms to unlock opportunities and drive innovation.\nHere, as a work in progress, I share my experiences, discoveries, and the lessons learned along the way with companies and fellow data enthusiasts. Dive into my courses, read through case studies, or reach out directly if you have any data related question!\n\n\n\n\nCatholic University of Leuven, Leuven | Belgium Bio-engineering Sciences\n\n\n\n\n\nUC Leuven-Limburg Research & Expertise | Data Scientist | April 2018 - present\nIMEC | Process Engineer | Sept 2012 - April 2018\n\n\n \n  \n   \n  \n    \n     LinkedIn"
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "Danny Volkaerts",
    "section": "",
    "text": "Catholic University of Leuven, Leuven | Belgium Bio-engineering Sciences"
  },
  {
    "objectID": "index.html#experience",
    "href": "index.html#experience",
    "title": "Danny Volkaerts",
    "section": "",
    "text": "UC Leuven-Limburg Research & Expertise | Data Scientist | April 2018 - present\nIMEC | Process Engineer | Sept 2012 - April 2018"
  },
  {
    "objectID": "sql_course/index_sql.html",
    "href": "sql_course/index_sql.html",
    "title": "SQL Cursus",
    "section": "",
    "text": "SQL, of Structured Query Language, is een fundamenteel hulpmiddel voor iedereen die geïnteresseerd is in opslag, verwerking of data analyse. Met de exponentiële groei van gegevens in de huidige digitale wereld is het essentieel om deze gegevens efficiënt te kunnen bevragen, manipuleren en analyseren. SQL is de standaardtaal voor relationele databasemanagementsystemen en stelt gebruikers in staat om op een eenvoudige en efficiënte manier met databases om te gaan. Kennis van SQL stelt dataprofielen in staat om zinvolle inzichten te halen uit grote datasets, gegevensanalyses uit te voeren en gegevens in te voeren in hun modellen voor machine learning. Inzicht in SQL opent mogelijkheden in data-analyse, data-engineering en daarbuiten, waardoor het een essentiële vaardigheid is voor elk aspirant-dataprofiel."
  },
  {
    "objectID": "sql_course/index_sql.html#chapters",
    "href": "sql_course/index_sql.html#chapters",
    "title": "SQL Course",
    "section": "Chapters",
    "text": "Chapters\n\nIntroduction to SQL and Databases\nOverview of SQL, databases, and how they are used in data science.\n\n\n\nBasic SQL Queries\nLearning SELECT statements, filtering data with WHERE clauses.\n\n\n\nWorking with Multiple Tables\nIntroduction to JOIN operations and their importance.\n\n\n\nAdvanced Data Manipulation\nUsing GROUP BY, HAVING, and aggregate functions.\n\n\n\nSubqueries, Nested Queries and Views\nEnhancing queries with subqueries for complex data retrieval.\n\n\n\nEach chapter is a step on your journey to mastering SQL. Let’s embark on this learning adventure together."
  },
  {
    "objectID": "sql_course/1_introduction.html#hr-sample-data",
    "href": "sql_course/1_introduction.html#hr-sample-data",
    "title": "Introduction SQL",
    "section": "HR sample data",
    "text": "HR sample data\nHere we will use a sample Database called HR that manages the HR data of the small businesses which is collected from www.sqltutorial.org. And to create the database, a SQLite script file was used when rendering the document. Read the extension docs for details."
  },
  {
    "objectID": "sql_course/1_introduction.html#erd-of-hr-database",
    "href": "sql_course/1_introduction.html#erd-of-hr-database",
    "title": "Introduction SQL",
    "section": "ERD of HR database",
    "text": "ERD of HR database\nThe following database diagram illustrates the HR sample database:\n\nFigure 1: ERD of HR database"
  },
  {
    "objectID": "sql_course/1_introduction.html#editable-example",
    "href": "sql_course/1_introduction.html#editable-example",
    "title": "Introduction SQL",
    "section": "Editable Example",
    "text": "Editable Example\nAnd now, you can run all sort of queries from the tables of the HR databases.\n\nselect * from regions;"
  },
  {
    "objectID": "sql_course/1_introduction.html#not-editable-example",
    "href": "sql_course/1_introduction.html#not-editable-example",
    "title": "Introduction SQL",
    "section": "Not editable example",
    "text": "Not editable example\nYou can also create “not-editable” code chunk (that is, you simply can run the query but won’t be able to edit/modify it) for HR database. And to do this, just use another instance of database under the database key in the yaml with a different name and use the option editable: false."
  },
  {
    "objectID": "sql_course/1_introduction.html#not-editable-example-1",
    "href": "sql_course/1_introduction.html#not-editable-example-1",
    "title": "Introduction SQL",
    "section": "Not editable example",
    "text": "Not editable example\n\nselect * from employees;"
  },
  {
    "objectID": "sql_course/1_introduction.html",
    "href": "sql_course/1_introduction.html",
    "title": "Introductie SQL",
    "section": "",
    "text": "https://dannyvolkaerts.github.io/\nManier van werken: 1. EERD graag afdrukken of naast je houden op ander scherm 2. Interactie via Wooclap -&gt; ik ben mee met het verhaal of niet, eventueel enkele tussenvragen om te pijlen hoe ze mee zijn\nOefeningen via Azure Data Studio: New connection - Microsoft SQL Server\nI created two databases DV_first_group and DV_second_group in the database. Here are the login details :\nserver url : 34.155.20.3\nport : 1433\nusername : student\npassword : ipL@7~@;Tn3n”.Eu\ndatabase : either DV_first_group or DV_second_group\n\nFor the admin connection, you can use :\nusername : sqlserver\npassword : 2NzIxYmz414v\n\nExtentions links - MySQL -&gt; installeren\n\n\n\n\nSQL (Structured Query Language) is de standaard taal om te communiceren met relationele databases. Ze wordt gebruikt voor insert, search, update en delete functionaliteiten.\n\nData opvragen: SQL laat toe om efficient data op te vragen uit de database.\nData Manipulatie: Wijzigen van de data\nData Integriteit: Het onderhouden van de accuraatheid en betrouwbaarheid van de database.\n\nOntwikkeld door IBM (1974)\n\n\n\n\n\nEen relationele database slaat gegevens op in tabellen\nGegevens worden georganiseerd in rijen en kolommen\nVoorbeelden zijn MySQL, PostgreSQL, MS SQL en SQLite\n\n\nverschil tussen database zelf en clients Azure Data Studio = client MySQL workbench = client PG Admin = client\n\n\n\n\n\n\nTabellen: Informatie opslaan in rijen en kolommen\nQueries: Het ophalen of toevoegen van data op basis van specifieke criteria\nSchemas: Weergeven van de structuur van de database\n\n\n\n\n\n\nData-analist: gebruikt SQL om databases te doorzoeken en inzichten te extraheren.\nData engineer: ontwerpt en onderhoudt databasemanagementsystemen, gebruikt SQL om datapijplijnen te creëren.\nData scientist: gebruikt SQL om gegevens voor te bereiden en op te schonen voor analyse.\nDatabaseontwikkelaar: creëert en optimaliseert databases, schrijft stored procedures en complexe queries."
  },
  {
    "objectID": "sql_course/1_introduction.html#inleiding-tot-sql-and-databases",
    "href": "sql_course/1_introduction.html#inleiding-tot-sql-and-databases",
    "title": "Introductie SQL",
    "section": "Inleiding tot SQL and Databases",
    "text": "Inleiding tot SQL and Databases\n\nhttps://dannyvolkaerts.github.io/\nManier van werken: 1. EERD graag afdrukken of naast je houden op ander scherm 2. Interactie via Wooclap -&gt; ik ben mee met het verhaal of niet, eventueel enkele tussenvragen om te pijlen hoe ze mee zijn\nOefeningen via Azure Data Studio: New connection - Microsoft SQL Server\nI created two databases DV_first_group and DV_second_group in the database. Here are the login details :\n\nExtentions links - MySQL -&gt; installeren"
  },
  {
    "objectID": "sql_course/1_introduction.html#sql-in-actie",
    "href": "sql_course/1_introduction.html#sql-in-actie",
    "title": "Introductie SQL",
    "section": "SQL in actie",
    "text": "SQL in actie"
  },
  {
    "objectID": "sql_course/5_subqueries.html",
    "href": "sql_course/5_subqueries.html",
    "title": "Subqueries and views",
    "section": "",
    "text": "Wat is een subquery?\n\nSELECT    first_name, last_name, employees.department_id, \n          departments.department_id, department_name\nFROM employees    INNER JOIN departments \n                  ON departments.department_id = employees.department_id\nWHERE departments.department_name = 'Purchasing';\n\n\n\n\nsubquery - voorbeeld 1\nGeef me de verschillende jobtitels van departement ‘Purchasing’.\n\n\n\n\nSubquery voorbeeld 1\nGeef me de verschillende jobtitels van departement ‘Purchasing’.\n\nSELECT job_title, department_name\nFROM employees e  INNER JOIN departments d ON d.department_id = e.department_id\n                  INNER JOIN jobs j ON j.job_id = e.job_id\nWHERE d.department_name = 'Purchasing';\n\n\nDISTINCT\n\n\n\n\nLEFT JOIN (& RIGHT JOIN)\n\nDefinitie: Geeft alle rijen uit de linkertabel terug, samen met de overeenkomstige rijen uit de rechtertabel. Als er geen overeenkomst is, worden de resultaten voor de rechtertabel NULL.\nGebruik: Nuttig om te zien welke rijen in de linkertabel geen overeenkomstige rijen in de rechtertabel hebben.\n\nSELECT kolommen\nFROM tabel1\nLEFT JOIN tabel2\nON tabel1.gemeenschappelijke_kolom = tabel2.gemeenschappelijke_kolom;\n\n\n\nLEFT JOIN voorbeeld\n\n\n\n\nLEFT JOIN voorbeeld\n\nSELECT c.country_name, c.country_id, l.country_id, l.street_address, l.city\nFROM countries c LEFT JOIN locations l ON l.country_id = c.country_id\nWHERE c.country_id IN ('US', 'UK', 'CN')\n\n\nOefening: lijst alle landen (naam) die geen locatie hebben in de database:\nSELECT country_name\nFROM countries c LEFT JOIN locations l ON l.country_id = c.country_id\nWHERE l.location_id IS NULL\n\n\n\n\nLEFT JOIN voorbeeld 2\n\n\n\n\nLEFT JOIN voorbeeld 2\n\nSELECT r.region_name, c.country_name, l.street_address, l.city\nFROM regions r    LEFT JOIN countries c ON c.region_id = r.region_id\n                  LEFT JOIN locations l ON l.country_id = c.country_id\nWHERE c.country_id IN ('US', 'UK', 'CN');\n\n\n\n\nFULL OUTER JOIN\n\nDefinitie: Geeft alle rijen terug van beide tabellen, ook wanneer er geen overeenkomst is in een van de tabellen.\nGebruik: Nuttig om alle overeenkomsten en verschillen tussen twee tabellen te zien.\n\nSELECT kolommen\nFROM tabel1\nFULL OUTER JOIN tabel2\nON tabel1.gemeenschappelijke_kolom = tabel2.gemeenschappelijke_kolom;\n\n\n\nFULL OUTER JOIN voorbeeld\nWe maken enkele tabellen aan om dit voorbeeld uit te werken: We creëren de tabel ‘mand’ en tabel ‘fruit’, waarbij we willen bijhouden welk stuk fruit in welke mand zit.\n\n\n\n\nCREATE TABLE mand (\nmand_id INTEGER PRIMARY KEY,\nmand_naam VARCHAR (255) NOT NULL\n);\n\nCREATE TABLE fruit (\nfruit_id INTEGER PRIMARY KEY,\nfruit_naam VARCHAR (255) NOT NULL,\nmand_id INTEGER\n);\n\nINSERT INTO mand (mand_id, mand_naam)\nVALUES\n(1, ‘A’),\n(2, ‘B’),\n(3, ‘C’);\n\nINSERT INTO fruit (\nfruit_id,\nfruit_naam,\nmand_id\n)\nVALUES\n(1, ‘Appel’, 1),\n(2, ‘Sinaasappel’, 1),\n(3, ‘Banaan’, 2),\n(4, ‘Aardbei’, NULL);\n\nAlle manden met fruit, fruit dat niet in een mand zit en manden zonder fruit -&gt; FULL OUTER\nSELECT\nmand_naam,\nfruit_naam\nFROM fruit FULL OUTER JOIN mand ON mand.mand_id = fruit.mand_id;\n\nLege mand die geen fruit heeft:\nSELECT\nmand_naam,\nfruit_naam\nFROM\nfruit\nFULL OUTER JOIN mand ON mand.mand_id = fruit.mand_id\nWHERE\nfruit_naam IS NULL;\n\n\n\n\n\nSELF JOIN\n\nDefinitie: Een SELF JOIN is een normale join, maar dan wordt de tabel met zichzelf gejoined, alsof het twee verschillende tabellen waren.\nGebruik: Nuttig om relaties binnen dezelfde tabel te vergelijken.\n\nSELECT a.kolom_name, b.kolom_name\nFROM tabel a, tabel b\nWHERE a.gemeenschappelijke_kolom = b.gemeenschappelijke_kolom AND voorwaarde;\n\n\n\nSELF JOIN voorbeeld\nWe kijken na welke employee aan welke manager rapporteert:\n\n\n\n\nSELF JOIN voorbeeld\nWe kijken na welke employee aan welke manager rapporteert:\n\nSELECT  e.first_name || ' ' || e.last_name AS employee, \n        m.first_name || ' ' || m.last_name AS manager\nFROM employees e INNER JOIN employees m ON m.employee_id = e.manager_id\nORDER BY manager;\n\n\n\n\nSELF JOIN voorbeeld\nDe CEO heeft geen manager maar deze willen we ook graag in het resultaat. Hoe doen we dit?\n\nSELECT  e.first_name || ' ' || e.last_name AS employee,\n        m.first_name || ' ' || m.last_name AS manager\nFROM employees e ...\n\n\nSELECT\ne.first_name || ’ ’ || e.last_name AS employee,\nm.first_name || ’ ’ || m.last_name AS manager\nFROM\nemployees e\nLEFT JOIN\nemployees m ON m.employee_id = e.manager_id\nORDER BY manager;\n\n\n\n\n\nOefeningen"
  },
  {
    "objectID": "sql_course/2_basics.html",
    "href": "sql_course/2_basics.html",
    "title": "Basics of SQL",
    "section": "",
    "text": "Topics\n\nBasisstructuur SQL queries\nSELECT statement om kolommen te halen van tabellen\nWHERE clausule om rijen te filteren\nSorteren van het resultaat met ORDER BY\nLimiteren van resultaat met LIMIT\n\n\n\n\nBasisstructuur\n\n\n\n\n\n\n\nQuery\nUitvoering\n\n\n\n\nSELECT\nFROM\nWHERE\nGROUP BY\nHAVING\nORDER BY\nLIMIT\nFROM\nWHERE\nGROUP BY\nHAVING\nSELECT\nORDER BY\nLIMIT\n\n\n\n\n\n\nSELECT Statement\nDe SELECT-instructie wordt gebruikt om gegevens uit een database te selecteren. De geretourneerde gegevens worden opgeslagen in een resultatentabel, ook wel de result-set genoemd.\nSELECT column1, column2 \nFROM table_name;\n\n\n\nSELECT *\nDe ‘*’ instructie wordt gebruikt om de volledige inhoud van de tabel te bekijken.\n\nSELECT * \nFROM regions;\n\n\n\n\nWHERE Statement\nDe WHERE-statement wordt gebruikt om specifieke rijen te selecteren die voldoen aan één of meerdere voorwaarden.\nVoorbeeld: ik wil de werknemers (employees) met een salaris hoger dan 16000 euro.\n\nSELECT first_name as voornaam, last_name as achternaam, salary as salaris \nFROM employees\nWHERE salary &gt; 16000;\n\n\n\n\nWHERE voorbeeld\nIk wil een overzicht van de werknemers (employees) die werken in het IT departement.\n\n// we zoeken eerst de code voor het IT-departement\nSELECT *\nFROM departments;\n// daarna zoeken we de werknemers die binnen dit departement werken\nSELECT first_name, last_name, department_id\nFROM employees\nWHERE department_id = '6';\n\n\n\n\nWHERE - combineren\nCombineren van filters kan met ‘AND’, ‘OR’, ‘NOT’\nVoorbeeld: Ik zoek de werknemers (employees) die werken in het IT departement EN een salaris hebben lager dan 18000 euro.\n\nSELECT first_name, last_name, department_id, salary\nFROM employees\nWHERE department_id = '6' \nAND salary &lt; 18000;\n\n\n\n\nWHERE - operatoren\n= != &gt;= &gt; IN LIKE IS NULL IS NOT NULL\n\nSELECT first_name, last_name, salary\nFROM employees\nWHERE last_name LIKE 'Ma%'\n\n\n\n\nSELECT DISTINCT\n\nSELECT DISTINCT salary\nFROM employees\n\n\n\n\nSELECT functies\n\n\n\nOperatie\nDefinitie\n\n\n\n\nCOUNT\nAantal lijnen\n\n\nAVG\nGemiddelde van de waarden\n\n\nSUM\nSom van de waarden\n\n\nMIN / MAX\nMinimum / Maximum waarde\n\n\n\n\n\n\nSELECT functies voorbeeld"
  },
  {
    "objectID": "sql_course/4_advanced.html",
    "href": "sql_course/4_advanced.html",
    "title": "Advanced Data Manipulation",
    "section": "",
    "text": "Inhoud\n\nAggregatie functies\n\nGROUP BY\n\nHAVING\n\nFuncties (tekst, numeriek, datum/tijd)\n\n\n\n\n\nAggregatie functies\n\n\n\nOperatie\nDefinitie\n\n\n\n\nCOUNT\nAantal lijnen\n\n\nAVG\nGemiddelde van de waarden\n\n\nSUM\nSom van de waarden\n\n\nMIN / MAX\nMinimum / Maximum waarde\n\n\n\n\n\n\nAggregatie functies voorbeeld\nGemiddelde salaris van de werknemers:\n\nSELECT AVG(salary) as 'gemiddelde salaris'\nFROM employees;\n\n\nMAX MIN\n\n\n\n\nGROUP BY\n\nDefinitie: De GROUP BY-clausule is een optionele clausule van de SELECT-instructie. Met de GROUP BY clausule kun je rijen groeperen op basis van de waarden van een of meer kolommen. Voor elke groep wordt één rij geretourneerd.\nGebruik: Maken van samenvattingen\n\nSELECT column1, column2, aggregate_function(column3)\nFROM table_name\nGROUP BY\n  column1,\n    column2;\n\n\n\nGROUP BY voorbeeld\nTellen van het aantal werknemers per departement\n\nSELECT department_id, COUNT(employee_id) headcount\nFROM employees\nGROUP BY department_id;\n\n\nWe willen de departementsnaam erbij:\nSELECT\ndepartment_name,\nCOUNT(employee_id) headcount\nFROM\nemployees e\nINNER JOIN departments d ON d.department_id = e.department_id\nGROUP BY\nd.department_id;\n\nWe willen geordend per headcount:\nORDER BY headcount DESC;\n\n\n\n\n\nGROUP BY voorbeeld 2\nGroeperen op meerdere kolommen:\n\nSELECT department_name, job_title, COUNT(employee_id)\nFROM employees e  INNER JOIN departments d ON d.department_id = e.department_id\n                  INNER JOIN jobs j ON j.job_id = e.job_id\nGROUP BY department_name, job_title;\n\n\nDefinieer de vraagstelling van deze query\n\n\n\n\nHAVING\n\nDefinitie: HAVING wordt gebruikt om voorwaarden te filteren die op de resultaten van aggregatiefuncties van toepassing zijn. Terwijl de WHERE-clausule wordt gebruikt om rijen te filteren voordat aggregatie plaatsvindt, wordt HAVING gebruikt om rijen te filteren na de aggregatie.\nGebruik: Essentieel in gevallen waar je voorwaarden wilt toepassen op groepen van data die door de GROUP BY-clausule zijn verzameld.\n\nSELECT column1, column2, AGGREGATE_FUNCTION (column3)\nFROM table1\nGROUP BY\n  column1,\n    column2\nHAVING\n    group_condition;\n\n\n\nHAVING voorbeeld\nWe willen de managers en het aantal werknemer die aan hen direct rapporteren:\n\nSELECT manager_id, first_name, last_name, COUNT(employee_id) direct_reports\nFROM employees\nWHERE manager_id IS NOT NULL\nGROUP BY manager_id;\n\n\nManagers met minstens 5 werknemers die direct aan hun rapporteren:\n\nHAVING direct_reports &gt;= 5;\n\n\n\n\n\nHAVING voorbeeld 2\nTotale salaris voor elk departement (met een totale salaris tussen de 20k en 30k): Vul aan!\n\nSELECT department_id, SUM(salary) as totaal\nFROM employees\nGROUP BY department_id\nORDER BY SUM(salary);\n\n\nHAVING SUM(salary) BETWEEN 20000 AND 30000\nORDER BY SUM(salary);\n\n\n\n\n\nJullie kunnen nu een eenvoudige VOLLEDIGE query uitvoeren!\n\n\n\nFuncties\n\n\n\nText functies\nLet op dialect!\nDownload PDF file.\n\n\n\nText functies voorbeeld\n\nSELECT LOWER(department_name)\nFROM departments\nORDER BY LOWER(department_name);\n\n\n\n\nText functies voorbeeld 2\n\nUPDATE employees \nSET email = UPPER(email);\n\n\n\n\nCASE functie\nWerkverjaardagen:\n\nSELECT first_name, last_name, hire_date,\n    --CASE (2000 - YEAR(hire_date))\n    CASE (2024 - strftime('%Y',hire_date))\n        WHEN 1 THEN '1 jaar'\n        WHEN 10 THEN '10 jaar'\n        WHEN 20 THEN '20 jaar'\n        WHEN 30 THEN '30 jaar'\n    END as verjaardag\nFROM\n    employees\nORDER BY first_name;\n\n\n\n\nSEARCHED CASE\nCASE\nWHEN boolean_expression_1 THEN\n    result_1\nWHEN boolean_expression_2 THEN\n    result_2\nWHEN boolean_expression_3 THEN\n    result_3\nELSE\n    else_result\nEND;\n\n\n\nSEARCHED CASE voorbeeld\n\nSELECT first_name, last_name,salary,\n    CASE\n        WHEN salary &lt; 3000 THEN 'Low'\n        WHEN salary &gt;= 3000 AND salary &lt;= 5000 THEN 'Average'\n        WHEN salary &gt; 5000 THEN 'High'\n    END evaluation\nFROM\n    employees;"
  },
  {
    "objectID": "sql_course/index_sql.html#hoofdstukken",
    "href": "sql_course/index_sql.html#hoofdstukken",
    "title": "SQL Cursus",
    "section": "Hoofdstukken",
    "text": "Hoofdstukken\n\nInleiding tot SQL en databases\nOverzicht van SQL, databases en hoe ze worden gebruikt in data science.\n\n\n\nBasis SQL Queries\nLeren van SELECT statements en filteren van data met WHERE clauses.\n\n\n\nWerken met combineren van tabellen\nIntroductie tot JOIN operaties en hun belang.\n\n\n\nGeavanceerde Data Manipulatie\nGebruik van GROUP BY, HAVING en aggregatiefuncties.\n\n\n\nSubqueries, geneste Queries en Views\nUitbreiding van queries met subqueries voor complexere data opvraging.\n\n\n\nData Definition Language (DDL) & Data Manipulation Language (DML)\nBegrijpen hoe een databank gemaakt wordt en invoegen, updaten en deleten van data in de databank.\n\n\n\nSQL en PowerBI\nKennis halen uit data door het bundelen van de kracht van SQL met PowerBI.\n\n\n\nOefeningen H1 en H2\nOefeningen hoofstuk 1 en 2.\n\n\n\nOefeningen H3\nOefeningen hoofstuk 3 - joins.\n\n\n\nEach chapter is a step on your journey to mastering SQL. Let’s embark on this learning adventure together."
  },
  {
    "objectID": "sql_course/7_powerbi.html#waarom-powerbi-en-sql---belang-van-data-intelligentie",
    "href": "sql_course/7_powerbi.html#waarom-powerbi-en-sql---belang-van-data-intelligentie",
    "title": "Integratie van SQL in PowerBI",
    "section": "Waarom PowerBI en SQL? - Belang van Data-intelligentie",
    "text": "Waarom PowerBI en SQL? - Belang van Data-intelligentie"
  },
  {
    "objectID": "sql_course/7_powerbi.html#concept-en-werkwijze",
    "href": "sql_course/7_powerbi.html#concept-en-werkwijze",
    "title": "Integratie van SQL in PowerBI",
    "section": "Concept en Werkwijze",
    "text": "Concept en Werkwijze"
  },
  {
    "objectID": "sql_course/7_powerbi.html#voorbeelden-van-powerbi-en-sql",
    "href": "sql_course/7_powerbi.html#voorbeelden-van-powerbi-en-sql",
    "title": "Integratie van SQL in PowerBI",
    "section": "Voorbeelden van PowerBI en SQL",
    "text": "Voorbeelden van PowerBI en SQL"
  },
  {
    "objectID": "sql_course/8_exercises.html#de-tennisvereniging",
    "href": "sql_course/8_exercises.html#de-tennisvereniging",
    "title": "Oefeningen hoofdstuk 1 en 2: tennis",
    "section": "De Tennisvereniging",
    "text": "De Tennisvereniging"
  },
  {
    "objectID": "sql_course/Tennis_uitleg.html",
    "href": "sql_course/Tennis_uitleg.html",
    "title": "De Tennisvereniging",
    "section": "",
    "text": "Database schema\n\n\n\nBelangrijke informatie bij de tennis database\nDe tennisvereniging is opgericht in 1970 en vanaf het begin wordt een aantal administratieve gegevens in een database opgeslagen. Deze database bestaat uit de volgende tabellen: spelers, teams, wedstrijden, boetes en bestuursleden.\n\nDe spelerstabel bevat gegevens over spelers die lid zijn van de tennisvereniging, zoals namen, adressen en geboortedatums. Toetreding tot de vereniging vindt altijd plaats op 1 januari van een bepaald jaar. Spelers kunnen dus niet midden in een jaar lid worden. De spelerstabel bevat geen historische gegevens. Als een speler zijn of haar lidmaatschap opzegt, verdwijnt hij of zij uit de tabel. Ook bij eventuele verhuizingen wordt het oude adres overschreven met het nieuwe adres, het oude adres wordt dus nergens bewaard.\n\nDe tennisvereniging kent twee soorten leden: recreatiespelers en wedstrijdspelers. De eerste groep speelt alleen onderlinge wedstrijden, dus geen wedstrijden tegen spelers van andere verenigingen. De resultaten van de onderlinge wedstrijden worden niet geregistreerd. Wedstrijdspelers spelen in teamverband tegen spelers van andere verenigingen. De resultaten van deze wedstrijden worden wel bijgehouden. Elke speler heeft een uniek nummer, ongeacht of deze wedstrijdspeler is of niet. Dit spelersnummer wordt door de vereniging uitgedeeld. Het is verplicht dat elke wedstrijdspeler bij de tennisbond geregistreerd staat.\n\nDe bond, die een nationaal instituut is, geeft elke wedstrijdspeler een uniek bondsnummer. Dit bondsnummer bestaat meestal uit cijfers, maar kan ook letters bevatten. Als een wedstrijdspeler geen wedstrijden meer speelt, maar recreatiespeler wordt, vervalt het bondsnummer. Let wel, recreatiespelers hebben dus geen bondsnummer, maar wel een spelersnummer.\n\nDe tennisvereniging heeft een aantal teams dat meedoet in competities. Voor elk team worden de aanvoerder en de divisie waarin het team op dat moment uitkomt, geregistreerd. De aanvoerder hoeft geen wedstrijden voor het team gespeeld te hebben. Het zou kunnen dat een bepaalde speler op een bepaald moment aanvoerder van twee of meer teams is. Ook in deze tabel wordt geen historie bijgehouden. Bij promotie of degradatie van een team naar een andere divisie wordt de geregistreerde divisie eenvoudigweg overschreven. Hetzelfde geldt voor de aanvoerder van een team: bij wisseling wordt het nummer van de oude aanvoerder overschreven.\n\nEen team bestaat uit een aantal spelers. Als een team tegen een team van een andere vereniging speelt, speelt elke speler van dat team een wedstrijd tegen een speler van het andere team (we gaan voor het gemak ervan uit dat wedstrijden waarbij koppels tegen elkaar spelen niet voorkomen). Het team waarvan de meeste spelers hun wedstrijd winnen is winnaar.\n\nEen team bestaat niet altijd uit dezelfde groep spelers. Bij ziekte of vakanties zijn soms invallers nodig. Een speler kan dus voor meerdere teams uitkomen. Als we spreken over ‘de spelers van een team’, dan bedoelen we dus de spelers die minstens één wedstrijd voor het team gespeeld hebben. Nogmaals, alleen spelers met een bondsnummer mogen officiële wedstrijden spelen.\n\nEen tenniswedstrijd is opgebouwd uit een aantal sets. Degene die de meeste sets heeft gewonnen is winnaar. Voor elke wedstrijd wordt vooraf bepaald bij hoeveel gewonnen sets de wedstrijd gewonnen is. Over het algemeen wordt de wedstrijd gestopt als een van de twee spelers twee of drie sets gewonnen heeft. Mogelijke eindstanden van een tenniswedstrijd zijn dus 2-1 of 2-0 als gespeeld wordt totdat een van de spelers twee sets gewonnen heeft (best of three), of 3-2, 3-1 of 3-0 als gespeeld wordt tot drie gewonnen sets (best of five). Een speler kan zijn of haar wedstrijd winnen of verliezen, gelijkspel is niet mogelijk. In de wedstrijdentabel wordt voor elke wedstrijd apart bijgehouden welke speler de wedstrijd heeft gespeeld en voor welk team. Tevens wordt geregistreerd hoeveel sets de speler heeft gewonnen en verloren. Hieruit is af te leiden of hij of zij de wedstrijd gewonnen heeft.\n\nVoor onreglementair gedrag van spelers (te late opkomst, agressief gedrag of niet verschijnen) worden door de bond boetes opgelegd. Boetes worden door de vereniging betaald. Na betaling worden ze in de boetestabel geregistreerd. Zolang een speler wedstrijden speelt, blijven alle boetes bewaard die voor hem of haar opgelegd en betaald zijn.\n\nAls een speler de vereniging verlaat, worden al zijn of haar gegevens in de vijf tabellen vernietigd. Als de vereniging een team terugtrekt, worden alle gegevens over dat team uit de teams- en wedstrijdentabel verwijderd. Als een wedstrijdspeler stopt met het spelen van wedstrijden en hij of zij dus weer recreant wordt, worden alle wedstrijd- en boetegegevens uit de desbetreffende tabellen verwijderd.\n\nSinds 1 januari 1990 wordt in de bestuursledentabel bijgehouden wie er in het bestuur zitten. Vier functies worden onderscheiden: voorzitter, penningmeester, secretaris en algemeen lid. Elk jaar op 1 januari wordt een nieuw bestuur gekozen. Wanneer een speler een bestuursfunctie bekleedt, worden de begin- en einddatum hiervan geregistreerd. Als iemand nog actief is, wordt er geen einddatum ingevuld.\n\n\n\nEnkele aandachtspunten\nIn het database schema willen we even wijzen op enkele punten:\n\nMerk op dat het spelersnummer een centrale rol in het schema heeft. Het is in één tabel de primaire sleutel en in de vier andere tabellen de externe sleutel (‘foreign key’).\n\nDe bestuursledentabel heeft een samengestelde primaire sleutel. In de figuur zie je dat aan de twee sleutelicoontjes, in de code staan er twee kolommen in de PRIMARY KEY.\n\nEen veelgemaakte fout is geen rekening houden met het feit dat het spelersnummer in de teamstabel het nummer is van de kapitein van een team. Om te weten wie effectief wedstrijden gespeeld heeft, moet je in de wedstrijdentabel het spelersnummer gebruiken."
  },
  {
    "objectID": "sql_course/8_exercises.html#basis-h1h2",
    "href": "sql_course/8_exercises.html#basis-h1h2",
    "title": "Oefeningen hoofdstuk 1 en 2: tennis",
    "section": "BASIS (H1,H2)",
    "text": "BASIS (H1,H2)"
  },
  {
    "objectID": "sql_course/9_exercises_joins.html#de-tennisvereniging",
    "href": "sql_course/9_exercises_joins.html#de-tennisvereniging",
    "title": "Oefeningen hoofdstuk 3: tennis joins",
    "section": "De Tennisvereniging",
    "text": "De Tennisvereniging"
  },
  {
    "objectID": "sql_course/9_exercises_joins.html#joins-h3",
    "href": "sql_course/9_exercises_joins.html#joins-h3",
    "title": "Oefeningen hoofdstuk 3: tennis joins",
    "section": "JOINS (H3)",
    "text": "JOINS (H3)"
  }
]