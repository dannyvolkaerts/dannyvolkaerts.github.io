[
  {
    "objectID": "SQL.html#hr-sample-data",
    "href": "SQL.html#hr-sample-data",
    "title": "Interactive-sql",
    "section": "HR sample data",
    "text": "HR sample data\nHere we will use a sample Database called HR that manages the HR data of the small businesses which is collected from www.sqltutorial.org. And to create the database, a SQLite script file was used when rendering the document. Read the extension docs for details."
  },
  {
    "objectID": "SQL.html#erd-of-hr-database",
    "href": "SQL.html#erd-of-hr-database",
    "title": "Interactive-sql",
    "section": "ERD of HR database",
    "text": "ERD of HR database\nThe following database diagram illustrates the HR sample database:\n\nFigure 1: ERD of HR database"
  },
  {
    "objectID": "SQL.html#editable-example",
    "href": "SQL.html#editable-example",
    "title": "Interactive-sql",
    "section": "Editable Example",
    "text": "Editable Example\nAnd now, you can run all sort of queries from the tables of the HR databases.\n\nselect * from regions;"
  },
  {
    "objectID": "SQL.html#not-editable-example",
    "href": "SQL.html#not-editable-example",
    "title": "Interactive-sql",
    "section": "Not editable example",
    "text": "Not editable example\nYou can also create “not-editable” code chunk (that is, you simply can run the query but won’t be able to edit/modify it) for HR database. And to do this, just use another instance of database under the database key in the yaml with a different name and use the option editable: false."
  },
  {
    "objectID": "SQL.html#not-editable-example-1",
    "href": "SQL.html#not-editable-example-1",
    "title": "Interactive-sql",
    "section": "Not editable example",
    "text": "Not editable example\n\nselect * from employees;"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Danny Volkaerts",
    "section": "",
    "text": "Hi! Welcome to my digital space! As a data enthousiast I’m fueled by curiosity and motivated by the goal of turning data into actionable insights. Whether it’s through Machine Learning, data analysis, or data visualizations, I explore data in all its forms to unlock opportunities and drive innovation.\nHere, as a work in progress, I share my experiences, discoveries, and the lessons learned along the way with companies and fellow data enthusiasts. Dive into my courses, read through case studies, or reach out directly if you have any data related question!\n\n\n\n\nCatholic University of Leuven, Leuven | Belgium Bio-engineering Sciences\n\n\n\n\n\nUC Leuven-Limburg Research & Expertise | Data Scientist | April 2018 - present\nIMEC | Process Engineer | Sept 2012 - April 2018\n\n\n \n  \n   \n  \n    \n     LinkedIn"
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "Danny Volkaerts",
    "section": "",
    "text": "Catholic University of Leuven, Leuven | Belgium Bio-engineering Sciences"
  },
  {
    "objectID": "index.html#experience",
    "href": "index.html#experience",
    "title": "Danny Volkaerts",
    "section": "",
    "text": "UC Leuven-Limburg Research & Expertise | Data Scientist | April 2018 - present\nIMEC | Process Engineer | Sept 2012 - April 2018"
  },
  {
    "objectID": "sql_course/index_sql.html",
    "href": "sql_course/index_sql.html",
    "title": "SQL Cursus",
    "section": "",
    "text": "SQL, of Structured Query Language, is een fundamenteel hulpmiddel voor iedereen die geïnteresseerd is in opslag, verwerking of data analyse. Met de exponentiële groei van gegevens in de huidige digitale wereld is het essentieel om deze gegevens efficiënt te kunnen bevragen, manipuleren en analyseren. SQL is de standaardtaal voor relationele databasemanagementsystemen en stelt gebruikers in staat om op een eenvoudige en efficiënte manier met databases om te gaan. Kennis van SQL stelt dataprofielen in staat om zinvolle inzichten te halen uit grote datasets, gegevensanalyses uit te voeren en gegevens in te voeren in hun modellen voor machine learning. Inzicht in SQL opent mogelijkheden in data-analyse, data-engineering en daarbuiten, waardoor het een essentiële vaardigheid is voor elk aspirant-dataprofiel."
  },
  {
    "objectID": "sql_course/index_sql.html#chapters",
    "href": "sql_course/index_sql.html#chapters",
    "title": "SQL Course",
    "section": "Chapters",
    "text": "Chapters\n\nIntroduction to SQL and Databases\nOverview of SQL, databases, and how they are used in data science.\n\n\n\nBasic SQL Queries\nLearning SELECT statements, filtering data with WHERE clauses.\n\n\n\nWorking with Multiple Tables\nIntroduction to JOIN operations and their importance.\n\n\n\nAdvanced Data Manipulation\nUsing GROUP BY, HAVING, and aggregate functions.\n\n\n\nSubqueries, Nested Queries and Views\nEnhancing queries with subqueries for complex data retrieval.\n\n\n\nEach chapter is a step on your journey to mastering SQL. Let’s embark on this learning adventure together."
  },
  {
    "objectID": "sql_course/1_introduction.html#hr-sample-data",
    "href": "sql_course/1_introduction.html#hr-sample-data",
    "title": "Introduction SQL",
    "section": "HR sample data",
    "text": "HR sample data\nHere we will use a sample Database called HR that manages the HR data of the small businesses which is collected from www.sqltutorial.org. And to create the database, a SQLite script file was used when rendering the document. Read the extension docs for details."
  },
  {
    "objectID": "sql_course/1_introduction.html#erd-of-hr-database",
    "href": "sql_course/1_introduction.html#erd-of-hr-database",
    "title": "Introduction SQL",
    "section": "ERD of HR database",
    "text": "ERD of HR database\nThe following database diagram illustrates the HR sample database:\n\nFigure 1: ERD of HR database"
  },
  {
    "objectID": "sql_course/1_introduction.html#editable-example",
    "href": "sql_course/1_introduction.html#editable-example",
    "title": "Introduction SQL",
    "section": "Editable Example",
    "text": "Editable Example\nAnd now, you can run all sort of queries from the tables of the HR databases.\n\nselect * from regions;"
  },
  {
    "objectID": "sql_course/1_introduction.html#not-editable-example",
    "href": "sql_course/1_introduction.html#not-editable-example",
    "title": "Introduction SQL",
    "section": "Not editable example",
    "text": "Not editable example\nYou can also create “not-editable” code chunk (that is, you simply can run the query but won’t be able to edit/modify it) for HR database. And to do this, just use another instance of database under the database key in the yaml with a different name and use the option editable: false."
  },
  {
    "objectID": "sql_course/1_introduction.html#not-editable-example-1",
    "href": "sql_course/1_introduction.html#not-editable-example-1",
    "title": "Introduction SQL",
    "section": "Not editable example",
    "text": "Not editable example\n\nselect * from employees;"
  },
  {
    "objectID": "sql_course/1_introduction.html",
    "href": "sql_course/1_introduction.html",
    "title": "Introduction SQL",
    "section": "",
    "text": "Here we will use a sample Database called HR that manages the HR data of the small businesses which is collected from www.sqltutorial.org. And to create the database, a SQLite script file was used when rendering the document. Read the extension docs for details."
  },
  {
    "objectID": "sql_course/1_introduction.html#inleiding-tot-sql-and-databases",
    "href": "sql_course/1_introduction.html#inleiding-tot-sql-and-databases",
    "title": "Introductie SQL",
    "section": "Inleiding tot SQL and Databases",
    "text": "Inleiding tot SQL and Databases"
  },
  {
    "objectID": "sql_course/1_introduction.html#sql-in-actie",
    "href": "sql_course/1_introduction.html#sql-in-actie",
    "title": "Introductie SQL",
    "section": "SQL in actie",
    "text": "SQL in actie"
  },
  {
    "objectID": "sql_course/5_subqueries.html",
    "href": "sql_course/5_subqueries.html",
    "title": "Subqueries and views",
    "section": "",
    "text": "Wat is een subquery?\n\nSELECT    first_name, last_name, employees.department_id, \n          departments.department_id, department_name\nFROM employees    INNER JOIN departments \n                  ON departments.department_id = employees.department_id\nWHERE departments.department_name = 'Purchasing';\n\n\n\n\nsubquery - voorbeeld 1\nGeef me de verschillende jobtitels van departement ‘Purchasing’.\n\n\n\n\nSubquery voorbeeld 1\nGeef me de verschillende jobtitels van departement ‘Purchasing’.\n\nSELECT job_title, department_name\nFROM employees e  INNER JOIN departments d ON d.department_id = e.department_id\n                  INNER JOIN jobs j ON j.job_id = e.job_id\nWHERE d.department_name = 'Purchasing';\n\n\nDISTINCT\n\n\n\n\nLEFT JOIN (& RIGHT JOIN)\n\nDefinitie: Geeft alle rijen uit de linkertabel terug, samen met de overeenkomstige rijen uit de rechtertabel. Als er geen overeenkomst is, worden de resultaten voor de rechtertabel NULL.\nGebruik: Nuttig om te zien welke rijen in de linkertabel geen overeenkomstige rijen in de rechtertabel hebben.\n\nSELECT kolommen\nFROM tabel1\nLEFT JOIN tabel2\nON tabel1.gemeenschappelijke_kolom = tabel2.gemeenschappelijke_kolom;\n\n\n\nLEFT JOIN voorbeeld\n\n\n\n\nLEFT JOIN voorbeeld\n\nSELECT c.country_name, c.country_id, l.country_id, l.street_address, l.city\nFROM countries c LEFT JOIN locations l ON l.country_id = c.country_id\nWHERE c.country_id IN ('US', 'UK', 'CN')\n\n\nOefening: lijst alle landen (naam) die geen locatie hebben in de database:\nSELECT country_name\nFROM countries c LEFT JOIN locations l ON l.country_id = c.country_id\nWHERE l.location_id IS NULL\n\n\n\n\nLEFT JOIN voorbeeld 2\n\n\n\n\nLEFT JOIN voorbeeld 2\n\nSELECT r.region_name, c.country_name, l.street_address, l.city\nFROM regions r    LEFT JOIN countries c ON c.region_id = r.region_id\n                  LEFT JOIN locations l ON l.country_id = c.country_id\nWHERE c.country_id IN ('US', 'UK', 'CN');\n\n\n\n\nFULL OUTER JOIN\n\nDefinitie: Geeft alle rijen terug van beide tabellen, ook wanneer er geen overeenkomst is in een van de tabellen.\nGebruik: Nuttig om alle overeenkomsten en verschillen tussen twee tabellen te zien.\n\nSELECT kolommen\nFROM tabel1\nFULL OUTER JOIN tabel2\nON tabel1.gemeenschappelijke_kolom = tabel2.gemeenschappelijke_kolom;\n\n\n\nFULL OUTER JOIN voorbeeld\nWe maken enkele tabellen aan om dit voorbeeld uit te werken: We creëren de tabel ‘mand’ en tabel ‘fruit’, waarbij we willen bijhouden welk stuk fruit in welke mand zit.\n\n\n\n\nCREATE TABLE mand (\nmand_id INTEGER PRIMARY KEY,\nmand_naam VARCHAR (255) NOT NULL\n);\n\nCREATE TABLE fruit (\nfruit_id INTEGER PRIMARY KEY,\nfruit_naam VARCHAR (255) NOT NULL,\nmand_id INTEGER\n);\n\nINSERT INTO mand (mand_id, mand_naam)\nVALUES\n(1, ‘A’),\n(2, ‘B’),\n(3, ‘C’);\n\nINSERT INTO fruit (\nfruit_id,\nfruit_naam,\nmand_id\n)\nVALUES\n(1, ‘Appel’, 1),\n(2, ‘Sinaasappel’, 1),\n(3, ‘Banaan’, 2),\n(4, ‘Aardbei’, NULL);\n\nAlle manden met fruit, fruit dat niet in een mand zit en manden zonder fruit -&gt; FULL OUTER\nSELECT\nmand_naam,\nfruit_naam\nFROM fruit FULL OUTER JOIN mand ON mand.mand_id = fruit.mand_id;\n\nLege mand die geen fruit heeft:\nSELECT\nmand_naam,\nfruit_naam\nFROM\nfruit\nFULL OUTER JOIN mand ON mand.mand_id = fruit.mand_id\nWHERE\nfruit_naam IS NULL;\n\n\n\n\n\nSELF JOIN\n\nDefinitie: Een SELF JOIN is een normale join, maar dan wordt de tabel met zichzelf gejoined, alsof het twee verschillende tabellen waren.\nGebruik: Nuttig om relaties binnen dezelfde tabel te vergelijken.\n\nSELECT a.kolom_name, b.kolom_name\nFROM tabel a, tabel b\nWHERE a.gemeenschappelijke_kolom = b.gemeenschappelijke_kolom AND voorwaarde;\n\n\n\nSELF JOIN voorbeeld\nWe kijken na welke employee aan welke manager rapporteert:\n\n\n\n\nSELF JOIN voorbeeld\nWe kijken na welke employee aan welke manager rapporteert:\n\nSELECT  e.first_name || ' ' || e.last_name AS employee, \n        m.first_name || ' ' || m.last_name AS manager\nFROM employees e INNER JOIN employees m ON m.employee_id = e.manager_id\nORDER BY manager;\n\n\n\n\nSELF JOIN voorbeeld\nDe CEO heeft geen manager maar deze willen we ook graag in het resultaat. Hoe doen we dit?\n\nSELECT  e.first_name || ' ' || e.last_name AS employee,\n        m.first_name || ' ' || m.last_name AS manager\nFROM employees e ...\n\n\nSELECT\ne.first_name || ’ ’ || e.last_name AS employee,\nm.first_name || ’ ’ || m.last_name AS manager\nFROM\nemployees e\nLEFT JOIN\nemployees m ON m.employee_id = e.manager_id\nORDER BY manager;\n\n\n\n\n\nOefeningen"
  },
  {
    "objectID": "sql_course/2_basics.html",
    "href": "sql_course/2_basics.html",
    "title": "Basics of SQL",
    "section": "",
    "text": "Topics\n\nBasisstructuur SQL queries\nSELECT statement om kolommen te halen van tabellen\nWHERE clausule om rijen te filteren\nSorteren van het resultaat met ORDER BY\nLimiteren van resultaat met LIMIT\n\n\n\n\nBasisstructuur\n\n\n\n\n\n\n\nQuery\nUitvoering\n\n\n\n\nSELECT\nFROM\nWHERE\nGROUP BY\nHAVING\nORDER BY\nLIMIT\nFROM\nWHERE\nGROUP BY\nHAVING\nSELECT\nORDER BY\nLIMIT\n\n\n\n\n\n\nSELECT Statement\nDe SELECT-instructie wordt gebruikt om gegevens uit een database te selecteren. De geretourneerde gegevens worden opgeslagen in een resultatentabel, ook wel de result-set genoemd.\nSELECT column1, column2 \nFROM table_name;\n\n\n\nSELECT *\nDe ‘*’ instructie wordt gebruikt om de volledige inhoud van de tabel te bekijken.\n\nSELECT * \nFROM regions;\n\n\n\n\nWHERE Statement\nDe WHERE-statement wordt gebruikt om specifieke rijen te selecteren die voldoen aan één of meerdere voorwaarden.\nVoorbeeld: ik wil de werknemers (employees) met een salaris hoger dan 16000 euro.\n\nSELECT first_name as voornaam, last_name as achternaam, salary as salaris \nFROM employees\nWHERE salary &gt; 16000;\n\n\n\n\nWHERE voorbeeld\nIk wil een overzicht van de werknemers (employees) die werken in het IT departement.\n\n// we zoeken eerst de code voor het IT-departement\nSELECT *\nFROM departments;\n// daarna zoeken we de werknemers die binnen dit departement werken\nSELECT first_name, last_name, department_id\nFROM employees\nWHERE department_id = '6';\n\n\n\n\nWHERE - combineren\nCombineren van filters kan met ‘AND’, ‘OR’, ‘NOT’\nVoorbeeld: Ik zoek de werknemers (employees) die werken in het IT departement EN een salaris hebben lager dan 18000 euro.\n\nSELECT first_name, last_name, department_id, salary\nFROM employees\nWHERE department_id = '6' \nAND salary &lt; 18000;\n\n\n\n\nWHERE - operatoren\n= != &gt;= &gt; IN LIKE IS NULL IS NOT NULL\n\nSELECT first_name, last_name, salary\nFROM employees\nWHERE last_name LIKE 'Ma%'\n\n\n\n\nSELECT DISTINCT\n\nSELECT DISTINCT salary\nFROM employees\n\n\n\n\nSELECT functies\n\n\n\nOperatie\nDefinitie\n\n\n\n\nCOUNT\nAantal lijnen\n\n\nAVG\nGemiddelde van de waarden\n\n\nSUM\nSom van de waarden\n\n\nMIN / MAX\nMinimum / Maximum waarde\n\n\n\n\n\n\nSELECT functies voorbeeld"
  },
  {
    "objectID": "sql_course/4_advanced.html",
    "href": "sql_course/4_advanced.html",
    "title": "Advanced Data Manipulation",
    "section": "",
    "text": "Inhoud\n\nAggregatie functies\n\nGROUP BY\n\nHAVING\n\nFuncties (tekst, numeriek, datum/tijd)\n\n\n\n\n\nAggregatie functies\n\n\n\nOperatie\nDefinitie\n\n\n\n\nCOUNT\nAantal lijnen\n\n\nAVG\nGemiddelde van de waarden\n\n\nSUM\nSom van de waarden\n\n\nMIN / MAX\nMinimum / Maximum waarde\n\n\n\n\n\n\nAggregatie functies voorbeeld\nGemiddelde salaris van de werknemers:\n\nSELECT AVG(salary) as 'gemiddelde salaris'\nFROM employees;\n\n\nMAX MIN\n\n\n\n\nGROUP BY\n\nDefinitie: De GROUP BY-clausule is een optionele clausule van de SELECT-instructie. Met de GROUP BY clausule kun je rijen groeperen op basis van de waarden van een of meer kolommen. Voor elke groep wordt één rij geretourneerd.\nGebruik: Maken van samenvattingen\n\nSELECT column1, column2, aggregate_function(column3)\nFROM table_name\nGROUP BY\n  column1,\n    column2;\n\n\n\nGROUP BY voorbeeld\nTellen van het aantal werknemers per departement\n\nSELECT department_id, COUNT(employee_id) headcount\nFROM employees\nGROUP BY department_id;\n\n\nWe willen de departementsnaam erbij:\nSELECT\ndepartment_name,\nCOUNT(employee_id) headcount\nFROM\nemployees e\nINNER JOIN departments d ON d.department_id = e.department_id\nGROUP BY\nd.department_id;\n\nWe willen geordend per headcount:\nORDER BY headcount DESC;\n\n\n\n\n\nGROUP BY voorbeeld 2\nGroeperen op meerdere kolommen:\n\nSELECT department_name, job_title, COUNT(employee_id)\nFROM employees e  INNER JOIN departments d ON d.department_id = e.department_id\n                  INNER JOIN jobs j ON j.job_id = e.job_id\nGROUP BY department_name, job_title;\n\n\nDefinieer de vraagstelling van deze query\n\n\n\n\nHAVING\n\nDefinitie: HAVING wordt gebruikt om voorwaarden te filteren die op de resultaten van aggregatiefuncties van toepassing zijn. Terwijl de WHERE-clausule wordt gebruikt om rijen te filteren voordat aggregatie plaatsvindt, wordt HAVING gebruikt om rijen te filteren na de aggregatie.\nGebruik: Essentieel in gevallen waar je voorwaarden wilt toepassen op groepen van data die door de GROUP BY-clausule zijn verzameld.\n\nSELECT column1, column2, AGGREGATE_FUNCTION (column3)\nFROM table1\nGROUP BY\n  column1,\n    column2\nHAVING\n    group_condition;\n\n\n\nHAVING voorbeeld\nWe willen de managers en het aantal werknemer die aan hen direct rapporteren:\n\nSELECT manager_id, first_name, last_name, COUNT(employee_id) direct_reports\nFROM employees\nWHERE manager_id IS NOT NULL\nGROUP BY manager_id;\n\n\nManagers met minstens 5 werknemers die direct aan hun rapporteren:\n\nHAVING direct_reports &gt;= 5;\n\n\n\n\n\nHAVING voorbeeld 2\nTotale salaris voor elk departement (met een totale salaris tussen de 20k en 30k): Vul aan!\n\nSELECT department_id, SUM(salary) as totaal\nFROM employees\nGROUP BY department_id\nORDER BY SUM(salary);\n\n\nHAVING SUM(salary) BETWEEN 20000 AND 30000\nORDER BY SUM(salary);\n\n\n\n\n\nJullie kunnen nu een eenvoudige VOLLEDIGE query uitvoeren!\n\n\n\nFuncties\n\n\n\nText functies\nLet op dialect!\nDownload PDF file.\n\n\n\nText functies voorbeeld\n\nSELECT LOWER(department_name)\nFROM departments\nORDER BY LOWER(department_name);\n\n\n\n\nText functies voorbeeld 2\n\nUPDATE employees \nSET email = UPPER(email);\n\n\n\n\nCASE functie\nWerkverjaardagen:\n\nSELECT first_name, last_name, hire_date,\n    --CASE (2000 - YEAR(hire_date))\n    CASE (2024 - strftime('%Y',hire_date))\n        WHEN 1 THEN '1 jaar'\n        WHEN 10 THEN '10 jaar'\n        WHEN 20 THEN '20 jaar'\n        WHEN 30 THEN '30 jaar'\n    END as verjaardag\nFROM\n    employees\nORDER BY first_name;\n\n\n\n\nSEARCHED CASE\nCASE\nWHEN boolean_expression_1 THEN\n    result_1\nWHEN boolean_expression_2 THEN\n    result_2\nWHEN boolean_expression_3 THEN\n    result_3\nELSE\n    else_result\nEND;\n\n\n\nSEARCHED CASE voorbeeld\n\nSELECT first_name, last_name,salary,\n    CASE\n        WHEN salary &lt; 3000 THEN 'Low'\n        WHEN salary &gt;= 3000 AND salary &lt;= 5000 THEN 'Average'\n        WHEN salary &gt; 5000 THEN 'High'\n    END evaluation\nFROM\n    employees;"
  },
  {
    "objectID": "sql_course/index_sql.html#hoofdstukken",
    "href": "sql_course/index_sql.html#hoofdstukken",
    "title": "SQL Cursus",
    "section": "Hoofdstukken",
    "text": "Hoofdstukken\n\nInleiding tot SQL en databases\nOverzicht van SQL, databases en hoe ze worden gebruikt in data science.\n\n\n\nBasis SQL Queries\nLeren van SELECT statements en filteren van data met WHERE clauses.\n\n\n\nWerken met combineren van tabellen\nIntroductie tot JOIN operaties en hun belang.\n\n\n\nGeavanceerde Data Manipulatie\nGebruik van GROUP BY, HAVING en aggregatiefuncties.\n\n\n\nSubqueries, geneste Queries en Views\nUitbreiding van queries met subqueries voor complexere data opvraging.\n\n\n\nData Definition Language (DDL) & Data Manipulation Language (DML)  Begrijpen hoe een databank gemaakt wordt en nvoegen, updaten en deleten van data in de databank.\n\n\n\nSQL en PowerBI  Kennis halen uit data door het bundelen van de kracht van SQL met PowerBI.\n\n–\n\nEach chapter is a step on your journey to mastering SQL. Let’s embark on this learning adventure together."
  },
  {
    "objectID": "sql_course/7_powerbi.html#waarom-powerbi-en-sql---belang-van-data-intelligentie",
    "href": "sql_course/7_powerbi.html#waarom-powerbi-en-sql---belang-van-data-intelligentie",
    "title": "Integratie van SQL in PowerBI",
    "section": "Waarom PowerBI en SQL? - Belang van Data-intelligentie",
    "text": "Waarom PowerBI en SQL? - Belang van Data-intelligentie"
  },
  {
    "objectID": "sql_course/7_powerbi.html#concept-en-werkwijze",
    "href": "sql_course/7_powerbi.html#concept-en-werkwijze",
    "title": "Integratie van SQL in PowerBI",
    "section": "Concept en Werkwijze",
    "text": "Concept en Werkwijze"
  },
  {
    "objectID": "sql_course/7_powerbi.html#voorbeelden-van-powerbi-en-sql",
    "href": "sql_course/7_powerbi.html#voorbeelden-van-powerbi-en-sql",
    "title": "Integratie van SQL in PowerBI",
    "section": "Voorbeelden van PowerBI en SQL",
    "text": "Voorbeelden van PowerBI en SQL"
  }
]